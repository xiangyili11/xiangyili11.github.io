<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pandas dataframe 更改列名</title>
      <link href="/2019/09/29/pandas-change-columns1/"/>
      <url>/2019/09/29/pandas-change-columns1/</url>
      
        <content type="html"><![CDATA[<p> 摘要：在生物信息学数据分析中，经常需要整合多个文档的数据，其中经常会遇到需要依据某个文件中的信息更改另外一个相关文件列名的问题，本文给出了一种更改方法。<br><a id="more"></a><br> 假设文件 A 包含信息如下：</p><div class="table-container"><table><thead><tr><th>chipID</th><th>drugID</th></tr></thead><tbody><tr><td>CVD001_HUH7_24H:BRD-A19037878:10</td><td>trichostatin-a</td></tr><tr><td>CVD001_HUH7_24H:BRD-A19500257:10</td><td>geldanamycin</td></tr><tr><td>CVD001_HUH7_24H:BRD-A29349577-001-04-0:2.5</td><td>dropropizine</td></tr><tr><td>CVD001_HUH7_24H:BRD-A36411721-001-01-0:14.3</td><td>BRD-A36411721</td></tr><tr><td>CVD001_HUH7_24H:BRD-A37828317-001-03-0:2.5</td><td>anthothecol</td></tr><tr><td>CVD001_HUH7_24H:BRD-A41649729-001-01-0:10</td><td>BRD-A41649729</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div><p> 文件 B 的标头是 chip ID，如果想要把 B 的表头改为 chipID 对应的 drugID, 那么方法可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">A_content = pd.read_table(A_filename,sep=&quot;\t&quot;)</span><br><span class="line"># 构造 chipID 为键，drugID 为值得字典 </span><br><span class="line">new_dict = dict(zip(A_content.chipID,A_content.drugID))</span><br><span class="line"># 读取 B 文件 </span><br><span class="line">B_content = pd.read_table(B_filename,sep=&quot;\t&quot;)</span><br><span class="line"># 更改 B 的列名 </span><br><span class="line">B_content.rename(columns=new_dict,inplace=True)</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h2>]]></content>
      
      
      <categories>
          
          <category> 计算机编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas dataframe��������</title>
      <link href="/2019/09/29/pandas-change-columns/"/>
      <url>/2019/09/29/pandas-change-columns/</url>
      
        <content type="html"><![CDATA[<p>ժҪ����������Ϣѧ���ݷ����У�������Ҫ���϶���ĵ������ݣ����о�����������Ҫ����ĳ���ļ��е���Ϣ��������һ������ļ����������⣬���ĸ�����һ�ָ��ķ�����<br><a id="more"></a><br>�����ļ�A������Ϣ���£�</p><div class="table-container"><table><thead><tr><th>chipID</th><th>drugID</th></tr></thead><tbody><tr><td>CVD001_HUH7_24H:BRD-A19037878:10</td><td>trichostatin-a</td></tr><tr><td>CVD001_HUH7_24H:BRD-A19500257:10</td><td>geldanamycin</td></tr><tr><td>CVD001_HUH7_24H:BRD-A29349577-001-04-0:2.5</td><td>dropropizine</td></tr><tr><td>CVD001_HUH7_24H:BRD-A36411721-001-01-0:14.3</td><td>BRD-A36411721</td></tr><tr><td>CVD001_HUH7_24H:BRD-A37828317-001-03-0:2.5</td><td>anthothecol</td></tr><tr><td>CVD001_HUH7_24H:BRD-A41649729-001-01-0:10</td><td>BRD-A41649729</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div><p>�ļ�B�ı�ͷ��chip ID�������Ҫ��B�ı�ͷ��ΪchipID��Ӧ��drugID,��ô���������ǣ�</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">A_content = pd.read_table(A_filename,sep=&quot;\t&quot;)</span><br><span class="line">#����chipIDΪ����drugIDΪֵ���ֵ�</span><br><span class="line">new_dict = dict(zip(A_content.chipID,A_content.drugID))</span><br><span class="line">#��ȡB�ļ�</span><br><span class="line">B_content = pd.read_table(B_filename,sep=&quot;\t&quot;)</span><br><span class="line">#����B������</span><br><span class="line">B_content.rename(columns=dd_dict,inplace=True)</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h2>]]></content>
      
      
      <categories>
          
          <category> �������� </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物网络的概念（二）：无标度网络（scale-free network)</title>
      <link href="/2019/09/22/labelFreeNetwork/"/>
      <url>/2019/09/22/labelFreeNetwork/</url>
      
        <content type="html"><![CDATA[<p>摘要：无标度网络（scale-free network）是一种重要的网络类型，因其能够很好地体现许多社会学、互联网以及生物学中的相互作用关系而受到了广泛的关注。本文将对无标度网络以及相关的概念进行初步的介绍。<br><a id="more"></a></p><h3 id="无标度网络的概念及其意义"><a href="# 无标度网络的概念及其意义" class="headerlink" title="无标度网络的概念及其意义"></a>无标度网络的概念及其意义 </h3><p> 无标度网络是一种所有节点（node）的度（degree）服从幂分布 (Power law distribution) 的网络 [1]。<br> 研究人员发现在很多网络中，少量的节点拥有整个网络的大部分连接度，而多数节点的连接度却非常小，这个现象符合幂分布的特点，并称这样的网络为无标度网络。如下图所示：</p><p><img src="/2019/09/22/labelFreeNetwork/network.PNG" alt></p><p>要想理解什么是无标度网络（scale-free network)首先要了解什么是幂分布。幂分布的定义是当样本数据较多时，变量 x 的概率密度函数：f(x)~x^(-α-1)。</p><p>不像正态分布那样个体的尺度在某个值附近变化很小，比如说人的身高、体重、智商，幂分布个体的尺度可以在很宽的范围内变化，这种波动往往可以跨越几个甚至几十个数量级。由此我们可以想到 20/80 法则、马太效应、“天之道，损有余而补不足；人之道则不然，损不足以奉有余”等等等等。幂分布充分地体现了重要的少数与琐碎的多数的关系，因此在社会学乃至生物学研究中都受到了广泛关注。</p><h3 id="构建无标度网络的方法步骤以及代码实现"><a href="# 构建无标度网络的方法步骤以及代码实现" class="headerlink" title="构建无标度网络的方法步骤以及代码实现"></a>构建无标度网络的方法步骤以及代码实现</h3><p>WGCNA（weighted gene co-expression netwrk analysis）是一种重要的构建共表达网络的方法，也是对应 R 包的名字。该方法就是基于输入的基因表达值（基因芯片或者 RNA-seq 数据），构建基于无标度网络的基因共表达网络，然后去分析基因之间的相似性、将具有相似功能的基因聚类成同一模块、将模块与不同性状联系起来以及鉴定模块内的驱动基因（driver gene）等等。使用 R 包 WGCNA 构建无标度网络的重要步骤是：</p><h4 id="（一）选取合适的 power 值（β）使得网络接近 scale-free 网络，选取β的代码及步骤如下（假定在 R 软件里已经安装好 WGCNA）："><a href="#（一）选取合适的 power 值（β）使得网络接近 scale-free 网络，选取β的代码及步骤如下（假定在 R 软件里已经安装好 WGCNA）：" class="headerlink" title="（一）选取合适的 power 值（β）使得网络接近 scale-free 网络，选取β的代码及步骤如下（假定在 R 软件里已经安装好 WGCNA）："></a>（一）选取合适的 power 值（β）使得网络接近 scale-free 网络，选取β的代码及步骤如下（假定在 R 软件里已经安装好 WGCNA）：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">## 导入 WGCNA 包</span><br><span class="line">library(&quot;WGCNA&quot;)</span><br><span class="line"></span><br><span class="line">## 构建幂的向量，一般构建 unsigned 网络，幂 power&lt;15；signed 网络幂 power&lt;30，这里以 unsigned 为例</span><br><span class="line">powers1=seq(from=1,to=15,by=1)</span><br><span class="line"></span><br><span class="line">## 导入包含样品基因表达量的文件，该文件第一列为基因名，列名为样品名称</span><br><span class="line">datExprdataOne1 = read.table(filepath,header = T,sep=&quot;\t&quot;)</span><br><span class="line"></span><br><span class="line">## 把重复的基因名字合并，使用平均值的方法；如果没有重复基因名该步骤也可以不做</span><br><span class="line">datExprdataOne2 = aggregate(datExprdataOne1[,2:dim(datExprdataOne1)[2]],by=list(datExprdataOne1[,1]),FUN=mean)</span><br><span class="line"></span><br><span class="line">## 把基因名字作为合并重复值后数据框的行名</span><br><span class="line">row.names(datExprdataOne2) &lt;- datExprdataOne2$Group.1</span><br><span class="line"></span><br><span class="line">## 删除 datExprdataOne2 的 Group.1 列</span><br><span class="line">datExprdataOne3 &lt;- datExprdataOne2[,2:dim(datExprdataOne2)[2]]</span><br><span class="line"></span><br><span class="line">## 将数据框转置，即列名为样品名称，行名为基因名称</span><br><span class="line">datExprdataOne = t(datExprdataOne3)</span><br><span class="line"></span><br><span class="line">## 遍历每一个 powers1 向量中的 power，寻找最优的 power</span><br><span class="line">pst=pickSoftThreshold(datExprdataOne,powerVector=powers1,moreNetworkConcepts=T)[[2]]</span><br><span class="line"></span><br><span class="line">## 遍历每一个 powers1 向量中的 power，将以该 power 为幂的网络相关指标展现出来</span><br><span class="line"></span><br><span class="line">tiff(PictureName,width=800,heiht=480,units=&quot;px&quot;,pointsize=10)</span><br><span class="line"></span><br><span class="line">cex1=1.2;cex.axis=1.5;cex.lab=1.5;cex.main=1.5</span><br><span class="line"></span><br><span class="line">par(mfrow=c(2,2),mar=c(4,4,3,2)+0.1)</span><br><span class="line"></span><br><span class="line">plot(powers1,-sign(pst[,3])*pst[,2],type=&quot;n&quot;,</span><br><span class="line">     xlab=&quot;Soft Threshold&quot;,</span><br><span class="line">     ylab=&quot;SFT,signed Rˆ2&quot;,cex.axis=cex.axis,cex.main=cex.main,</span><br><span class="line">     cex.lab=cex.lab,main=&quot;Scale Free Fit Index Rˆ2&quot;)</span><br><span class="line"></span><br><span class="line">text(powers1,-sign(pst[,3])*pst[,2],</span><br><span class="line">     labels=powers1,cex=cex1,col=&quot;red&quot;)</span><br><span class="line"></span><br><span class="line">plot(powers1,pst$Density,</span><br><span class="line">     type=&quot;n&quot;,xlab=&quot;Soft Threshold&quot;,ylab=&quot;Density&quot;,</span><br><span class="line">     cex.axis=cex.axis,cex.main=cex.main,cex.lab=cex.lab,</span><br><span class="line">     main=&quot;Density&quot;)</span><br><span class="line"></span><br><span class="line">text(powers1,pst$Density,labels=powers1,cex=cex1,col=&quot;red&quot;)</span><br><span class="line"></span><br><span class="line">plot(powers1,pst$Heterogeneity,type=&quot;n&quot;,xlab=&quot;Soft Threshold&quot;,</span><br><span class="line">     ylab=&quot;Heterogeneity&quot;,cex.main=cex.main,cex.lab=cex.lab,</span><br><span class="line">     cex.axis=cex.axis,main=&quot;Heterogeneity&quot;)</span><br><span class="line"></span><br><span class="line">text(powers1,pst$Heterogeneity,labels=powers1,cex=cex1,col=&quot;red&quot;)</span><br><span class="line"></span><br><span class="line">plot(powers1,pst$Centralization,type=&quot;n&quot;,xlab=&quot;Soft Threshold&quot;,</span><br><span class="line">     ylab=&quot;Centralization&quot;,cex.axis=cex.axis,cex.main=cex.main,</span><br><span class="line">     cex.lab=cex.lab,main=&quot;Centralization&quot;)</span><br><span class="line"></span><br><span class="line">text(powers1,pst$Centralization,labels=powers1,cex=cex1,col=&quot;red&quot;)</span><br><span class="line"></span><br><span class="line">dev.off()</span><br></pre></td></tr></table></figure><p>最终得到的图片形式类似下图所示：</p><p><img src="/2019/09/22/labelFreeNetwork/Cortex_expression_data_in_GTEx.txtdrop_median_0..png" alt></p><p>结果解释：<br>左上图：x 轴表示不同的 power 值；y 轴表示 scale-free topology index R2，该值越大表明其所对应的网络越接近 scale-free 网络。 一般情况下 power 的值越大，R2 越大。</p><p>右上图：x 轴表示不同的 power 值；y 轴表示网络的 Density，含义接近于网络的平均 connectivity，越大表示网络节点间相互联系越紧密，反之则不紧密，接近 scale-free 网络。一般情况下 power 值越大 Density 越小，网络越接近 scale-free 网络。</p><p>左下图：x 轴表示不同的 power 值；y 轴表示 Heterogeneity，用以衡量网络节点间 connectivity 的变异程度。</p><p>右下图：x 轴表示不同的 power 值；y 轴表示 Centralization，越接近 1 表明网络具有星形拓扑结构，越接近 0 表明网络每个节点具有相同的连接度。一般 power 值越小，Centralization 越大，网络越接近 scale-free 网络。</p><p>综上所述，考虑到上述四种指标，一般情况下 power 值的选择要看使 R2 超过 0.8 的最小 power 值。如果实在没有符合要求的 power，可选取经验值，即 unsigned 网络 power=6;signed 网络 power=12。</p><h4 id="（二）基于β值构建网络模块"><a href="#（二）基于β值构建网络模块" class="headerlink" title="（二）基于β值构建网络模块"></a>（二）基于β值构建网络模块 </h4><p> 使用上一步得到的 datExprdataOne 和β，构建基因共表达网络。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NetWork = blockwiseModules(datExprdataOne, power = β, maxBlockSize = nGenes,</span><br><span class="line">                       TOMType = type, minModuleSize = 30,</span><br><span class="line">                       reassignThreshold = 0, mergeCutHeight = 0.25,</span><br><span class="line">                       numericLabels = TRUE, pamRespectsDendro = FALSE,</span><br><span class="line">                       verbose = 3)</span><br></pre></td></tr></table></figure></p><p>重要参数解释：<br>power：经过第一步分析得到的最优 power 值；  </p><p>maxBlockSize: 一般情况下构建网络的时候会把输入的表达矩阵分成几份（block）分别计算。如果计算资源充足，最好不拆分矩阵。做法是 MaxBlockSize≥矩阵包含的基因数目；</p><p>TOMType: 值可以为”none”, “unsigned”, “signed”, “signed Nowick”, “unsigned 2”, “signed 2” and “signed Nowick 2”；  </p><p>numericaLabels: 逻辑值（F/T），F 则表示得到的模块用颜色标记，T 则表示得到的模块用数字标记。</p><p>后续下游分析可参考<a href="http://blog.sciencenet.cn/blog-118204-1111379.html" target="_blank" rel="noopener">WGCNA 分析，简单全面的最新教程</a>。</p><p>参考资料：<br>[1] Cesar A. Hidalgo and Albert-Laszlo Barabasi (2008), Scholarpedia, 3(1):1716.<br>[2] Langfelder, Peter, and Steve Horvath. “WGCNA: an R package for weighted correlation network analysis.” BMC bioinformatics 9.1 (2008): 559.</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生物网络的概念 </tag>
            
            <tag> WGCNA </tag>
            
            <tag> 无标度网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>药物基因组学数据库 Connectivity Map 使用方法简介（二）</title>
      <link href="/2019/09/14/Cmap_tools/"/>
      <url>/2019/09/14/Cmap_tools/</url>
      
        <content type="html"><![CDATA[<p>摘要：Connectivity Map(CMap)是 2006 年推出的数据库，之后经过一次更新，使得数据库包含了 1309 个小分子药物处理五类人类肿瘤细胞系后的约 7000 个基因表达谱数据。数据库历经十几年，仍然是研究药物基因组学的科研人员不可或缺的宝贵资源。CMap 数据库提供了的网页分析工具，本文将简要介绍一下其使用方法。<br><a id="more"></a></p><h3 id="数据准备"><a href="# 数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>1）用户需提供基于 Affy Metrix HG-U133A 或者 HT_HG-U133A_EA 或者 HT_HG-U133A 平台的基因芯片数据。因为 CMap 的 7000 多个基因芯片数据是基于上述平台的，其中 5000 多个是基于 HT_HG-U133A 平台的，所以基于模式匹配算法的网页工具也需要用户提供一致的数据类型。Affy Metrix 官网提供了将基因与探针集相互转化的信息和工具。</p><p>2）根据研究目的，提供相应的上下调探针集列表。例如，如果研究某种疾病，那么就要提供疾病组 vs 正常组的上调和下调探针集列表；如果要研究药物的作用，那么就要提供处理组 vs 对照组的上调和下调探针集列表（注：网站限制上下调探针集总数在 1000 以内）。<br>3）将上下调基因列表文件转化为.grp 格式。就是将上下调基因列表文件后缀名改为.grp。如下图所示:</p><p><img src="/2019/09/14/Cmap_tools/grp.PNG" alt></p><h3 id="数据处理"><a href="# 数据处理" class="headerlink" title="数据处理"></a>数据处理 </h3><p> 数据输入接口有四种，即</p><p><img src="/2019/09/14/Cmap_tools/query_page.PNG" alt></p><p>点击“浏览”，分别上传本地存放的上下调探针集列表文件。然后点击”execute query”执行分析，等待，点击“view results now”就可以看到分析结果。</p><p><img src="/2019/09/14/Cmap_tools/load_signature.PNG" alt></p><p>load signature 与 quick query 的区别就是：load signature 可以让用户对每一次的分析做个性化描述，这对同时执行多次不同分析的用户来说很有用，而 quick query 则简单粗暴，适合一次性分析，不提供数据描述和命名功能。</p><p><img src="/2019/09/14/Cmap_tools/signature_query.PNG" alt></p><p>用户想再重新分析一下以前上传的上下调探针集列表，可以使用 signature query。只要找到以前分析结果的名字即可直接用于新的分析。还有一种是选择数据库中自带的 instance 作为输入，研究该 instance 与 CMap 其他 instances 的联系，这种方法操作起来和上面差不多，在此不再赘述。</p><h3 id="结果解释"><a href="# 结果解释" class="headerlink" title="结果解释"></a>结果解释 </h3><p> 用户提交数据进行分析之后会得到分析结果，结果展示了基于 CMap 的模式匹配算法，用户提供的表达谱与 CMap 各个药物处理产生的表达谱相似或者相异程度。结果有两种展现方式。如下图所示：  </p><p><img src="/2019/09/14/Cmap_tools/results.PNG" alt><br>用户根据自己研究目的不同来选择不同的分析结果。一种是 detailed results(基于 connnectivity score 的展示方式)，该法是以单个 instance 为中心，也就是展示 CMap 数据库中每一个 instance 与用户提交探针集的关系（结果解释参见 <a href="http://eatdrinkbreathe.top/2019/09/01/ 药物基因组学数据库 Connectivity map 简介 /"> 药物基因组学数据库 Connectivity Map 使用方法简介（一）</a>）；另一种是 permuted results(基于 instance 集合的结果展示方式)，instance 集合的种类有三类，即同一种药物处理得到的 instance 集合（<strong>by name</strong>，不论什么浓度、处理什么细胞系、处理多长时间），同一药物处理同一细胞系的 instance 集合（<strong>by name and cell line</strong>，不论什么浓度、什么处理时长），同属于一个 ATC code 的药物处理得到的 instance 集合（<strong>by ATC code</strong>）。然后分别计算每个 instance 集合的 Enrichment score 和 p value，最终基于 p value 和 Enrichment score 对每个 instance 集合排序。结果如下图所示：</p><p><img src="/2019/09/14/Cmap_tools/enrichment_result.PNG" alt><br>第一列 <strong>rank</strong> 是每个 instance 集合的排名（基于 p value 升序排序，基于 enrichment 的绝对值降序排序）；</p><p>第二列是 instance 集合（by name，by name and cell line，by ATC code）的名称； </p><p>第三列 <strong>mean</strong> 是每个 instance 集合对用户探针集的 connectivity score 的平均值；  </p><p>第四列 <strong>n</strong> 是每个 instance 集合的大小；</p><p>第五列 <strong>erichment</strong> 是每个 instance 集合包含的 instance 的排名与所有 instance（7000 多个）排名的 KS 检验统计量，与 connectivity score 的区别是这里只有一个列表（即 instance 集合包含的 instance 排名），score = a 或者 -b；而计算 connectivity score 时 score = KSTop – KSBottom，要计算两次</p><p>第六列是计算每个 enrichment score 时的显著性 <strong>p</strong> 值。简单来说就是每次从所有 instance 中抽随机 n（每个 instance 集合的大小）个 instance，计算 enrichment score，重复操作十万次，计算出现绝对值大于 enrichment score 的次数 m，p=m/100000； </p><p>第七列 <strong>specificty</strong> 是指 312 个实验验证的上下调基因列表对每个 instance 集合的特异性。这 312 个具有明确生物学功能意义的列表可用于反映 instance 集合的功能特性；  </p><p>第八列 <strong>non-null</strong>是指 instance 集合中 connectivity score 不为零的 instance 所占百分比。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Connectivity Map </tag>
            
            <tag> 药物基因组学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>药物基因组学数据库 Connectivity Map 算法浅析</title>
      <link href="/2019/09/11/Cmap_algrith/"/>
      <url>/2019/09/11/Cmap_algrith/</url>
      
        <content type="html"><![CDATA[<p>摘要：Connectivity Map 是药物基因组学研究领域的一个宝库，近些年来有许多计算生物学家开始对这个重要数据库进行挖掘，进行了包括但不限于组合药物研究、药物重定位研究等等，也有许多计算生物学家对 connectivity map 网站提供的联结“药物 - 基因 - 疾病”的算法提出了改进。他山之石可以攻玉，本文将尝试对 connectivity map 所使用的 Kolmogorov–Smirnov test 进行初步的解读。</p><a id="more"></a><h3 id="拟合优度检验"><a href="# 拟合优度检验" class="headerlink" title="拟合优度检验"></a>拟合优度检验 </h3><p> 统计学学习中我们经常会遇到需要判断两组观测数据是否具有一致性的问题，解决办法之一就是拟合优度检验（Goodness of fit test）。拟合优度检验是基于卡方统计量进行统计的一种显著性检验，除了可以用来判断两组数据是否具有一致性外，也可以用来判断观测数据是否符合某种统计学分布。常见的拟合优度检验方法有：Neyman-Pearson χ2 拟合优度检验、Kolmogorov-Smirnov 检验等等。</p><h3 id="经验分布函数"><a href="# 经验分布函数" class="headerlink" title="经验分布函数"></a>经验分布函数 </h3><p> 设 x1,x2,…,xn 是总体 X 的一组容量为 n 的样本测量值，将它们按照从小到大的顺序重新排列为 x1∗,x2∗,⋯,xn∗，对于任意实数 x，定义函数 </p><script type="math/tex; mode=display">F_n(x)=\begin{cases}0,\quad x<x^*_1\\k/n,\quad x^*_{k}\leq x<x^*_{k+1}, \quad k=1,2,\cdots,n-1\\1,\quad x^*_n\leq x\end{cases}</script><p>则称 Fn(x)为总体 X 的经验分布函数。它还可以简记为 Fn(x)=1/n⋅ ∗{x1,x2,⋯,xn}，其中∗{x1,x2,⋯,xn}表示 x1,x2,⋯,xn 中不大于 x 的个数。<br>另外一种常见的表示形式为 </p><center> $F_n(x)=\frac{1}{n}\sum_{i=1}^nI\{x_i\leq x\}$ </center><p>其中，I 是 indicator function, 即 </p><center> $I\{x_i\leq x\}=\begin{cases}1,\quad x_i\leq x\\0,\quad otherwise\end{cases}$ </center><p>因此，求经验分布函数 Fn(x) 在一点 x 处的值，只要求出随机变量 X 的 n 个观测值 x1,x2,⋯,xnx 中小于或等于 x 的个数，再除以观测次数 n 即可。由此可见，Fn(x) 就是在 n 次重复独立实验中事件 {X≤x}出现的频率。</p><h3 id="KS 统计的基础知识"><a href="#KS 统计的基础知识" class="headerlink" title="KS 统计的基础知识"></a>KS 统计的基础知识</h3><p>K-S 检验全称是 Kolmogorov–Smirnov test，是一种非参数检验（参数检验与非参数检验的区别，简单来说就是：参数检验是检验平均数、方差等参数做的假设，而非参数检验则是对总体分布情况做的假设），基于累积分布函数，通过对两个分布之间的差异分析，判断两样本是否来自同一个总体或者判断某个样本分布是否服从特定分布。由于对分布函数的位置和形状参数的差异都敏感，K-S 检验成为比较两样本最有用且常规的非参数检验方法之一。</p><p>对于两个独立随机样本 X={X1,X2,X3,…,Xm}和 Y={Y1,Y2,Y3,…,Yn}, 设其经验分布函数分别为 F，G。如果想检验 X 和 Y 之间是否存在差异，首先<br>(1）提出假设 H0：Fn(x)=Gn(y)，那么可以建立以下假设：<br>H0：F(t) = G(t),  for every t<br>H1：F(t) ≠ G(t),  for at least one t</p><center> $F_n(x)=\frac{1}{m}\sum_{i=1}^mI\{x_i\leq x\}$ </center><center> $G_n(y)=\frac{1}{n}\sum_{i=1}^nI\{y_i\leq y\}$ </center><p>(2)  假设建立以后就要计算检验统计量了。K-S 检验的统计量定义是：样本累计频率与理论分布累计概率的绝对差，令最大的绝对差为 Dn，Dn=max{[Fn(x) - F(x)]};<br>(3) 用样本容量 n 和显著水平 a 查出临界值 Dna；<br>(4) 如果 Dn&lt; Dna，则认为拟合是满意的。</p><h3 id="connectivity-score 背后的假设及意义"><a href="#connectivity-score 背后的假设及意义" class="headerlink" title="connectivity score 背后的假设及意义"></a>connectivity score 背后的假设及意义 </h3><p> 如果某疾病引起的上调基因列表表达量的统计分布与某药物引起的下调基因列表表达量分布一致，同时 / 或者该疾病引起的下调基因列表表达量的统计分布与该药物引起的上调基因列表表达量分布一致，那么就可能说明疾病影响的基因与药物影响的基因属于同一分布，来自同一总体，而作用方向相反，正负得零，那么该药物就可能使疾病状态恢复到正常。</p><h3 id="connectivity-score 的计算方法"><a href="#connectivity-score 的计算方法" class="headerlink" title="connectivity score 的计算方法"></a>connectivity score 的计算方法 </h3><p> 由于 KS 检验是一种非参数方法，不依赖均值的位置，适用范围广，对于基因表达量的统计分布来说是比较稳妥的统计检验方法。因此 CMAP 算法采用基于排序的 Kolmogorov-Smirnov (KS)统计方法，将疾病基因表达谱与药物表达谱联系起来。KS 统计量（up score 和 down score）是根据疾病基因表达谱 (即 top 和 down 列表) 在药物表达谱中的排名计算得到的。<br>具体做法是：<br>(1) 将基因按照药物处理细胞系后产生变化的大小降序排列，即药物上调的倍数越大排名越靠前，rank=1, 2, …, 22283；<br>(2)将疾病基因列表与药物表达谱基因列表取交集，得到一个新的基因列表 CommonGenes；<br>(3) 得到 CommonGenes 在降序排序后药物表达谱的排名，然后将排名升序排列，假设向量大小为 t，则 j= 1, 2, …, t。构建经验分布函数，对于 CommonGenes 来说，其经验分布函数是</p><center> $F_n(j)=\frac{j}{t}$ </center><p>(4) 得到 CommonGenes 在降序排序后药物表达谱的排名，然后将排名升序排列得到向量 V（j），假设向量大小为 t，则 j= 1, 2, …,t。构建经验分布函数，对于 CommonGenes 来说，其经验分布函数是</p><center> $G_n(j)=\frac{V(j)}{n}$ </center><p>(5) 所以 CMap 算法的 KS 统计量计算公式为：</p><p><img src="/2019/09/11/Cmap_algrith/image011.gif" alt></p><p><img src="/2019/09/11/Cmap_algrith/image013.gif" alt></p><p>其中 if  a &gt; b，KSTop/Bottom = a<br>　　 else       KSTop/Bottom = -b；<br>　　 if  KSTop * KSBottom &lt; 0<br>　　 score = KSTop – KSBottom<br>　　 else  score = 0</p><p>对于该算法的一些理解：<br>（1）由于 KS 检验的统计量就是两个经验分布的最大距离（差值），那么计算 a 了之后为什么还要计算 b？我们可以看到 b 几乎等于 -a，仅仅加上了一个 1/t，当 t 很大时 1/t 可以忽略不计。这是因为 a 计算的时候包含正负符号，并不是真正意义上的距离（绝对值）。例如假设 a=max{-3,-2,-1,0,1,2}, 那么 a=2，我们知道 2 并不是最大距离，因为还有一个 -3, 因此为了得到真正意义上的最大距离，需要计算 b。</p><p>（2） 为什么 a &gt;  b 则 KS=a;b&gt;a 则 ks=-b 呢？为什么要加上一个负号？是因为这种方法可以区分以下两种情况：<br>①疾病上调基因列表于药物上调基因列表一致（a1&gt;b1，ksup=a1，以及疾病下调基因列表于药物下调基因列表一致 (b2&gt;a2，ksdown=b2)；<br>②疾病上调基因列表于药物下调基因列表一致(a3&lt; b3, ksdown=b3)，以及疾病下调基因列表于药物上调基因列表一致（a4&gt;b4，ksup=a4)；<br> 若 a &gt;b 则 KS=a;b&gt;a 则 ks=b，不加负号，则①情况 score = KSTop – KSBottom=a1-b2；②score = KSTop – KSBottom=b3-a4。在此 (a1-b2) 正负号未知，（b3-a4)正负号也未知，也就无法区分①、②两种情况。如若将 a &gt;b 则 KS=a;b&gt;a 则 ks=-b，则在此 (a1+b2) 始终为正，（-b3-a4)始终为负，也就区分①、②两种情况。如此，本人佩服算法研究人员的缜密与创造性！</p><p>(3) 为什么计算 b 的时候是 (j-1) 而不是 j？<a href="https://www.cnblogs.com/datamining-bio/p/8684420.html" target="_blank" rel="noopener">dedication</a>博客给出了比较合理的解答：</p><blockquote><blockquote><p>我们再来看看计算 b 的公式，它将 i 减了 1，即将集合 B 中的基因位置向前推了一位，这是为什么呢？我们看下图 8 的情况。<br><img src="/2019/09/11/Cmap_algrith/1362527-20180331215135026-1073998294.png" alt><br>当基因 Q 刚好在疾病中位于第 N 个，在药物数据中位于第 M 个，也就是说，该基因在疾病状态下被抑制，表达量非常少，而在药物作用下产生促进表达作用，表达量增加很多，很明显，该药物对该疾病的治疗效果应该很好，称为该疾病的特效药的可能性也很高，如果我们在计算 b 的时候，不减 1，那么 b=0，后面的异号条件也不满足，那么我们就漏掉了很好的这种情况，为了避免，就将集合 B 的基因位置向前推一个。</p></blockquote></blockquote><h3 id="参考资料"><a href="# 参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/datamining-bio/p/8684420.html" target="_blank" rel="noopener">KS 检验统计量的扩展应用（CMap）</a></p><p><a href="https://blog.csdn.net/baimafujinji/article/details/51720090" target="_blank" rel="noopener">经验分布函数（Empirical Distribution Functions）</a></p><p><a href="https://blog.csdn.net/qq_41679006/article/details/80977113" target="_blank" rel="noopener">Kolmogorov–Smirnov test（K-S 检验）</a></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Connectivity Map </tag>
            
            <tag> 药物基因组学 </tag>
            
            <tag> 拟合优度检验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>药物基因组学数据库 Connectivity Map 使用方法简介（一）</title>
      <link href="/2019/09/01/Cmap_tools1/"/>
      <url>/2019/09/01/Cmap_tools1/</url>
      
        <content type="html"><![CDATA[<p>摘要：Connectivity Map 是药物基因组学研究领域的重要数据库，是计算生物学和药物筛选研究人员做研究时不得不重视的数据库。它不仅提供大量宝贵的药物处理人类细胞系前后的基因表达谱数据，而且也提供了基于模式匹配算法的在线工具，用户提交合适的基因列表就能得到该数据库中与之相关的药物。<br><a id="more"></a></p><h3 id="Connectivity-map 的重要性及地位、发展历史及版本"><a href="#Connectivity-map 的重要性及地位、发展历史及版本" class="headerlink" title="Connectivity map 的重要性及地位、发展历史及版本"></a>Connectivity map 的重要性及地位、发展历史及版本 </h3><p> 做药物筛选试验的研究人员以及做计算生物学数据分析的研究人员，应该对美国博德研究所的 <a href="https://portals.broadinstitute.org/cmap/" target="_blank" rel="noopener">Connectivity Map</a>(CMap) 数据库都不陌生。CMap 是药物基因组学研究领域内非常重要的数据库，目前网页版数据库已更新至第二版。该数据库自 2006 年发布至 2019 年 9 月初已被引用超过 3000 次（数据来源于谷歌学术）。Cmap 旨在通过基因表达量的变化来发现药物、基因和疾病之间的功能联系。最近十年来在药物组合和药物重定位研究中扮演着越来越重要的角色。</p><h3 id="数据量及数据类型"><a href="# 数据量及数据类型" class="headerlink" title="数据量及数据类型"></a>数据量及数据类型</h3><p>CMap 数据库包含了 1309 种小分子药物处理 5 种人类肿瘤细胞系前后的基因芯片数据。处理条件多种多样，包括不同药物、不同浓度、不同处理时长等等，大多数处理条件都有三个处理样本以及对应的三个及以上空白对照组。</p><h3 id="CMap 的结果解释"><a href="#CMap 的结果解释" class="headerlink" title="CMap 的结果解释"></a>CMap 的结果解释 </h3><p> 做计算生物学的用户往往会把 CMap 所有的基因芯片数据下载下来然后做各自的后续分析，而对于普通湿实验用户，该数据库也提供了网页版分析工具，只要用户提供两个文档（分别包含上调基因和下调基因）就能够得到 CMap 中与用户提供基因列表相关（正相关和负相关）的药物列表，从而为用户进行药物分析提供指导。用户最感兴趣应该就是 barview 中红绿颜色代表的药物了，也就是 connectivity score 不为零的那些 instance 代表的药物。具体来说，用户按要求上传自己的基因列表后会得到数据库返回的结果，如下图所示:</p><p><img src="/2019/09/01/Cmap_tools1/cmap_result.PNG" alt></p><p>针对用户提供的两个基因列表:<br><strong>barview</strong>给出 CMap 所有 instance(一种药物在一种浓度下处理特定时长的一种细胞系，产生的数据就是一个 instance）与其关联度（connectivity score）的图形化展示。绿色代表正相关，红色代表负相关，灰色代表不相关。每个正值 connectivity score 代表正相关，背后的假设是药物扰动的表达谱与疾病扰动的表达谱正相关，可以简单地认为药物可以引起或者加剧该疾病状态；反之，每个负值 connectivity score 代表负相关，背后的假设是药物扰动的表达谱与疾病扰动的表达谱负相关，可以简单地认为药物能够减轻甚至逆转该疾病状态。  </p><p><strong>rank</strong>是所有 instance 放在一起后的 connectivity score 排名，connectivity score 越大排名越靠前。</p><p><strong>batch</strong>是 instance 产生的批次，7000 多个基因表达谱数据由多个不同批次产生。  </p><p><strong>dose</strong>药物处理细胞系时的浓度。</p><p><strong>cell line</strong>是药物处理的细胞系类型。</p><p><strong>score</strong>是指 connectivity score，由 up score 和 down score 计算后再经过标准化得到，是相对数值。</p><p><strong>up/down</strong>分别指用户上传的上调 / 下调基因列表对每个 instance 的打分，是绝对数值。 </p><p><strong>ATC</strong>是指该药物的 ATC code 值，是一种国际通用的药物分类系统。 </p><p><strong>instance_id</strong>是指每个 instance 的标识 ID。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Connectivity Map </tag>
            
            <tag> 数据库介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物码农 VS 计算生物学家</title>
      <link href="/2019/08/25/%E8%AE%A1%E7%AE%97%E7%94%9F%E7%89%A9%E5%AD%A6%E5%AE%B6/"/>
      <url>/2019/08/25/%E8%AE%A1%E7%AE%97%E7%94%9F%E7%89%A9%E5%AD%A6%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<p>摘要：时常在生物学招聘广告上看到招聘生物信息分析员、生物信息分析工程师、生物信息科学家甚至计算生物学家。所需要的学历、技能、经验依次成倍增加。生物码农是对会编程、跑流程，在公司里做着重复机械数据分析和文档写作工作的生信人的戏称。而计算生物学家则往往是在高校和研究所中独当一面的 PI。本文是一篇译文，两名计算生物学家给出了一些计算生物学领域的注意事项和建议。<br><a id="more"></a></p><h2 id="《所以，你想成为一名计算生物学家？》"><a href="#《所以，你想成为一名计算生物学家？》" class="headerlink" title="《所以，你想成为一名计算生物学家？》"></a>《所以，你想成为一名计算生物学家？》</h2><h3 id="原文信息：Loman-Nick-and-Mick-Watson-“So-you-want-to-be-a-computational-biologist-”-Nature-biotechnology-31-11-2013-996"><a href="# 原文信息：Loman-Nick-and-Mick-Watson-“So-you-want-to-be-a-computational-biologist-”-Nature-biotechnology-31-11-2013-996" class="headerlink" title="原文信息：Loman, Nick, and Mick Watson. “So you want to be a computational biologist?.” Nature biotechnology 31.11 (2013): 996."></a>原文信息：Loman, Nick, and Mick Watson. “So you want to be a computational biologist?.” Nature biotechnology 31.11 (2013): 996.</h3><p>计算生物学家往往身兼多个角色，包括数据分析工程师、数据管理员、数据库开发工程师、统计分析师、数学建模工程师、生物信息学工程师、软件开发工程师、存在论支持者等等。显然计算机是现代生物学研究的重要组成部分，生物学家们需要掌握计算生物学所要求的新技能和新技术。无论你是生命科学领域的一名研究生、一位教授或者其他什么人，如果你发现计算分析对你的研究越来越重要，请遵循下面的建议，沿着这条成为一名计算生物学家的路走下去!</p><h3 id="明确你的目标并选择合适的研究方法"><a href="# 明确你的目标并选择合适的研究方法" class="headerlink" title="明确你的目标并选择合适的研究方法"></a>明确你的目标并选择合适的研究方法 </h3><p> 要想学好计算生物学，关键是选择和使用适当的软件。在您能够合理地解释软件的输出结果之前，您必须了解软件在做什么（内部工作原理是什么）。就像如果你对聚合酶链反应的方法和原理没有基本的了解，你就不会进入实验室进行聚合酶链反应实验。对于计算生物学来说，为什么也要这样做呢? 因为理解软件的底层工作原理和算法有助于合理地解释输出结果。这并不意味着您需要通读每一行源代码，但是您应该对软件的基本原理和算法有概念上的了解。</p><p>软件工具通常是特定算法的实现，该算法可能非常适合特定类型的数据，例如在从头组装序列（de novo assembly)中，Overlap-Layout-Consensus 类软件适用于对长序列的组装，而 de Bruijn graphs 类软件则适合短序列的组装。选择采用最合适算法的软件将会为您节省大量时间。</p><h3 id="为自己和他人的脚本设置正负对照"><a href="# 为自己和他人的脚本设置正负对照" class="headerlink" title="为自己和他人的脚本设置正负对照"></a>为自己和他人的脚本设置正负对照 </h3><p> 您如何知道您的脚本、软件或流程正在正确地工作? 计算机会经常会基于奇怪的输入数据输出分析结果，而且没有任何报错信息，但这并不意味着没有问题。基于已知输出结果的小数据集进行测试（预实验），检查软件或分析流程是否能够重现该结果。试着对你希望找到的每一种类型的答案都这样做。仔细检查每种测试的结果，看看这些结果是否有意义。如果没有必要的正负对照，湿实验科学家是不会想着进行实验的，而这些测试在计算生物学实验中也发挥着同等作用。</p><h3 id="你是个科学家，不是程序员（码农）"><a href="# 你是个科学家，不是程序员（码农）" class="headerlink" title="你是个科学家，不是程序员（码农）"></a>你是个科学家，不是程序员（码农）</h3><p>要求太高反而难成功。你是一个科学家，科学研究工作完成的质量比你的源代码看起来有多漂亮更重要。如果输出结果是错误的，代码编写得再完美、文档再丰富、再优雅，那么它就是不如能输出正确结果的简单脚本有用。话虽如此，一旦您确定您的核心算法能够正常且正确地工作，就应该花点时间使它变得优雅些，并写出它的使用文档。尽可能多地运用你的生物学知识——这是你成为计算生物学家的根本。</p><h3 id="使用版本控制软件"><a href="# 使用版本控制软件" class="headerlink" title="使用版本控制软件"></a>使用版本控制软件 </h3><p> 版本控制软件能够跟踪你对代码的更改，帮助您维护多个版本的代码并与其他人协作。使用标准工具，如 Git 或 Subversion，您就可以轻松地发布代码。善待未来（那个阅读代码或者修改代码）的自己。解释您写代码时所做的选择以及您为什么要做这些选择的 ReadMe 文件，将在几个月或几年之后您返回到某项目时成为一件好事。编写代码和脚本的说明文档，以便帮自己和他人理解它们的作用。当发布您的研究成果时，请尝试同时发布用于生成研究结果的脚本和方法，以便其他人可以复制、重现它们。还可以考虑在你进行数据分析的时候，用一个数字化实验室记录本来记录你的分析结果。云存储数据库 (如 Github) 是理想的选择，它还可以帮助您维护存储库的副本并以此作为分析结果的离线备份。</p><h3 id="问问自己是否需要流程化"><a href="# 问问自己是否需要流程化" class="headerlink" title="问问自己是否需要流程化"></a>问问自己是否需要流程化 </h3><p> 流程化是指一系列按照预设的计划依次运行的脚本或软件工具。流程化非常适合以重复的方式运行完全相同的一组步骤以及与他人共享协议。但流程化可能会迫使您采用一种僵化的思维方式而降低创新性。警告: 不要过早地把自己的工作流程化。在将一个方法转换为一个流程之前，先让它正常工作。即便如此，它是否需要成为一个流程? 这样能节省时间吗? 你的流程真的对别人有用吗? 如果这些步骤只由您来操作，而一个简单的脚本可能就足够，那么任何尝试流程化的操作将是浪费时间。类似地，如果这些步骤只运行一次，那么就只运行一次而不必流程化，记录下您曾经运行过这些步骤，然后继续下去。</p><h3 id="奥巴马式思维模式"><a href="# 奥巴马式思维模式" class="headerlink" title="奥巴马式思维模式"></a>奥巴马式思维模式 </h3><p> 是的, 你可以的!（YES，YOU CAN！）作为一个计算生物学家，你需要有创造性，从改进现有的计算方法到达开发全新的方法的境界。也要敢于冒险，做好失败的准备，更要坚持下去。通过使用谷歌，请教领域内的专家，自学如何解决特定的问题，你也可以取得惊人的成就。参加培训课程也是有用的，但这些只是成为计算生物学家的学习的开始，而不是结束。之后继续坚持自学。</p><h3 id="科研需要质疑精神，尽信文献不如无文献"><a href="# 科研需要质疑精神，尽信文献不如无文献" class="headerlink" title="科研需要质疑精神，尽信文献不如无文献"></a>科研需要质疑精神，尽信文献不如无文献 </h3><p> 统计学训练中进行往往包含多个实验。首先，创建一个由随机数组成的大矩阵，并将列指定为实验组或对照组。然后对每一行进行统计测试，以分析实验组数据和对照组数据之间是否存在显著的差异。您将毫不惊讶地发现，得到的结果中有几百行的 P 值具有统计显著性。生物数据集（比如基因组学实验产生的数据集）庞大而充满噪音。您的数据分析将产生假阳性和假阴性结果，而且在实验中或分析中的数据也可能会引入系统性偏差。</p><p>即使在受过统计学理论训练的生物学家中，也有一种倾向，即当特定的软件或流程产生有趣的结果时，他们会把谨慎和怀疑精神抛诸脑后。而真正需要做的是：对结果持怀疑态度，并进行进一步的测试，以确定“有趣的”结果是否可以用实验误差或偏差来解释。如果多种方法结果一致，那么你就能提升对这些答案的信心。但对于许多实验的结果，需要进一步的实验室验证和分析工作。在解释计算生物学的分析结果时，生物学知识是至关重要的。如上所述，设置正负对照或测试只是计算生物学的一部分。这些测试旨在确保您的软件或分析流程按照您的预期在工作，即使如此这并不一定意味着所得到的答案是正确的。</p><h3 id="适合进行计算生物学分析的工具"><a href="# 适合进行计算生物学分析的工具" class="headerlink" title="适合进行计算生物学分析的工具"></a>适合进行计算生物学分析的工具 </h3><p> 您要熟练使用 UNIX/Linux 命令行进行工作。命令行的功能非常强大，它允许您更好地控制软件去做什么，并允许您同时运行和控制多个作业。大多数生物信息学软件的设计就是基于命令行运行的。您还需要了解计算集群以及如何并行运行数百个作业。你需要能够编写代码，但是编程语言种类的选择并不像计算机科学家所认为的那么重要。每种编程语言都有优缺点，你可能不得不使用多种语言来完成工作。</p><p>选择一种更流行的语言将使您受益，因为存在着更大的工具集库，例如来自 Open Bioinformatics Foundation 的 Bio* 项目。Microsoft Excel 是一个电子表格程序，除非非常小心地使用，否则不适合生物数据的存储和分析。建议将实验数据存储在结构化文本文件或 SQL 数据库中。采用基本的数据库操作方法，如数据标准化，可以使出错的机会更少。建议所有数据都定期备份。</p><h3 id="像侦探一样思考"><a href="# 像侦探一样思考" class="headerlink" title="像侦探一样思考"></a>像侦探一样思考 </h3><p> 作为一名计算生物学家，您将花费大量时间分析和解释数据。数据在告诉你一些事情。它们蕴含了一个故事，你的工作就是找出这个故事是什么。除非你非常幸运，大多数时候它不会显而易见。查明真相并不容易。你必须考虑实验是如何进行的、数据分析是如何进行的以及结果告诉你什么。你需要自信地忽略或控制数据中的错误和系统性偏差。要做到这一点，你可能需要与参与这项工作的其他科学家交谈，或者整合和分析额外的数据。您可能需要设计后续实验来测试您提出的任何实验假设。记住，真实的故事可能根本不出自您的数据中! 比如，如果你感兴趣的生物系统依赖于蛋白质的磷酸化，那么你可能不会在 RNA-seq 数据中看到这种效果。计算生物学家基本上是个侦探，折腾数据并发现真相。</p><h3 id="站在巨人的肩膀上"><a href="# 站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上 </h3><p> 你在做的工作很可能已经有人已经在研究过了，找到他们! 无论你的研究问题多么棘手，研究方法多么先进，很有可能已经有人尝试过解决它了。讨论软件相关问题的两个优秀资源是 <a href="http://www.biostars.org/" target="_blank" rel="noopener">BioStars</a> 和<a href="http://seqanswes.com/" target="_blank" rel="noopener">SEQanswers</a>。Twitter 是另一个你可以找到建议、资源和论文链接的地方。也可以与你所在系或研究所的其他计算生物学家联系。在您的领域也可能会有一个本地的计算生物学会议或兴趣小组，所以找到它并加入。如果没有，为什么不像尼克（本文作者之一）那样自己组建一个呢? 总之，如果您想进行计算生物学分析，可以通过在线和本地研究人员获得大量支持。有足够的勇气去尝试并从这些资源中学习是最好的起点。在你的电脑上安装 Linux 操作系统并开始学习一些在线的学习材料。你会惊讶于你能很快上手做出一些什么东西，最终这将成为你一个非常有益的经验!</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h3>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 译文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物网络的概念（一）：毗邻矩阵（Adjacency Matrix）</title>
      <link href="/2019/06/04/networkConcepts1/"/>
      <url>/2019/06/04/networkConcepts1/</url>
      
        <content type="html"><![CDATA[<p><strong> 网络的毗邻矩阵 </strong><br>&ensp;&ensp;&ensp;&ensp; 网络主要由节点（node）和边（edge）组成，是一种研究节点与节点相互关系的重要工具，如描述蛋白质之间相互作用的蛋白质相互作用网络，描述基因之间共表达关系的基因共表达网络等等。<a id="more"></a><br>&ensp;&ensp;&ensp;&ensp; 毗邻矩阵（Adjacency matrix）是一种描述网络中相邻两个节点连接程度（connection strength）的 n×n 维矩阵。设有一个毗邻矩阵 A，可以写成如下格式：</p><center> $A = (A_{ij})$ </center><p>&ensp;&ensp;&ensp;&ensp; 其中 Aij 分别表示第 i 个和第 j 个节点的毗邻值（可以理解为两个节点的相互关系强弱）。对于无加权网络（unweighted network）来说，若两个节点的相互关系大于某个阈值则 Aij 等于 1；反之，则这个值为 0。总而言之，无向网络（undirected network）的毗邻矩阵的性质如下：</p><center> $0 \leq A_{ij}  \leq1$ </center> <center> $A_{ij} = A_{ji}$ </center><center> $A_{ii} = 1$ </center> <hr><p><strong> 总连接度（connectivity)及其相关概念 </strong><br>&ensp;&ensp;&ensp;&ensp; 网络的总连接度 (connectivity) 又叫度(degree)。它的计算公式如下：</p><center> $k_i = \sum_{j \neq i}A_{ij}$ </center> <p>&ensp;&ensp;&ensp;&ensp; 在无加权网络中，节点 i 的总连接度 ki 就等于与节点 i 连接的所有点的总数目。<br>&ensp;&ensp;&ensp;&ensp; 在加权网络中，节点 i 的总连接度等于与节点 i 连接的各个点毗邻值（Aij)的总和。如下图所示：</p><p><img src="/2019/06/04/networkConcepts1/connectivity.PNG" alt></p><hr><p><strong> 社交网络分析：感染网络（Affection Network） </strong></p><p>&ensp;&ensp;&ensp;&ensp; 马克思曾给人下了个定义：人是各种社会关系的总和。可以通过人际关系网络来理解理解网络的基本特性。把人作为网络（人际关系网）的节点，两个人（节点）的亲近程度作为他们之间的感染力（毗邻值）。我们可以这样假设：两个人强烈地喜欢欣赏对方，那么他们之间的感染力就非常强（毗邻值 Aij 就等于 1）；若他们彼此无感、不感染（但也不排斥，Aij 就等于 0.5）；若他们彼此极度厌恶，那么没有一点感染力（Aij 就等于 0）。最终某个人与所有人的连接度之和（标化花后）可以作为他的受欢迎程度（connectivity)，这个 connectivity 值越大说明这个人越受人爱戴。</p><blockquote><p>参考资料：Horvath, Steve. Weighted network analysis: applications in genomics and systems biology. Springer Science &amp; Business Media, 2011.</p></blockquote><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 生物网络的概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《被伤害和侮辱的人们》读后感</title>
      <link href="/2019/06/01/%E8%A2%AB%E4%BC%A4%E5%AE%B3%E5%92%8C%E4%BE%AE%E8%BE%B1%E7%9A%84%E4%BA%BA%E4%BB%AC/"/>
      <url>/2019/06/01/%E8%A2%AB%E4%BC%A4%E5%AE%B3%E5%92%8C%E4%BE%AE%E8%BE%B1%E7%9A%84%E4%BA%BA%E4%BB%AC/</url>
      
        <content type="html"><![CDATA[<p><strong> 阅读后的思考（一）</strong><br>&ensp;&ensp;&ensp;&ensp; 近一段时间读完的一部长篇小说（继白鹿原、沉默的大多数、遥远的救世主、天幕红尘），感觉没有读完其他小说之后产生的震撼，虽然是俄国著名作家陀思妥耶夫斯基的著作。<a id="more"></a><br>&ensp;&ensp;&ensp;&ensp; 这部小说是我读过的第二部俄国文学作品（第一部是《钢铁是怎样炼成的》，奥斯特洛夫斯基作品）。先说中俄作家文风的区别，这部作品给人的感觉有点像戏剧，表演的色彩比较浓重，一幕一幕的。人物对白总有各种感叹、惊叹、感慨，可能为了呼应作品题目的悲剧色彩，小说中的人物（娜达莎、涅莉、娜达莎母亲）悲伤哭泣的场景非常多。而我国作家的作品（我所读过的），虽然作品中的主人公也有悲惨的经历，但是作者虽然也会刻意描写他们的悲伤情绪，会更加着重描写小说中人物的内心世界及其变化，着重描写小说人物悲惨经历后的思想变化以及对世界对人生感悟的升华。<br>&ensp;&ensp;&ensp;&ensp; 这部小说描写了一场畸形的爱情及其悲剧结局。以第一人称（瓦尼亚）的视角，来描写这场爱情悲剧。两小无猜青梅竹马的瓦尼亚和娜达莎已经私定终身了，却因公爵儿子的到来使得瓦尼亚痛失爱人。瓦尼亚痛心疾首，但是还是与娜达莎和平放手，更令人佩服的是他还继续做娜达莎的朋友，在危难时替娜达莎分担痛苦，成为其蓝颜知己。然而娜达莎和公爵儿子的爱情注定以悲剧收场。原因有以下两点：<br>&ensp;&ensp;&ensp;&ensp; 一、他们之间的感情不是成熟的爱情，而是依恋。公爵儿子在娜达莎眼里就是一个孩子，她爱的是其天真、真诚、诚实的品性，而公爵儿子则看中娜达莎的包容、溺爱之类的母性。他们之间的感情像母子之情。而比较好的爱情则应该是以平等为基础，彼此之间互相爱恋。母子之情，天生就是不平等的，一方只有付出，并且还是无私的付出，而另一方理所当然地接受。所以，当公爵儿子厌烦这种母爱的时候或者从另外的人那里也能得到满足的时候，他很可能就会离开娜达莎。<br>&ensp;&ensp;&ensp;&ensp; 二、家族仇恨，公爵和娜达莎父亲的私怨。他们之间的私人恩怨已经达到不共戴天的程度了，娜达莎竟然不管不顾，追逐仇人的儿子而去。这种追求爱情的方式不敢苟同，典型的自私行为。为了追求自己个人的幸福，给已经受到伤害的父母二次伤害。背负这样的心理负担，他们不可能收到世人认可。人毕竟是社会动物，被社会所遗弃，没有世人的认可，成为只有爱情的孤家寡人，应该很难长久维持爱情吧。<br>&ensp;&ensp;&ensp;&ensp; 爱情这东西真有这么厉害？能让人变成魔鬼也在所不惜？让人六亲不认？<br>&ensp;&ensp;&ensp;&ensp; 公爵是这部小说两条主线的链接人物。公爵——&gt; 公爵儿子——&gt; 娜达莎——&gt; 娜达莎父亲——&gt; 瓦尼亚，公爵——&gt; 涅莉母亲——&gt; 涅莉——&gt; 涅莉外公——&gt; 瓦尼亚。公爵这种人，就是唯利是图、见利忘义、蛇蝎心肠的典型代表，但是坏人、恶人也是有他们智慧、客观的一面。他对于道德的理解也让人眼前一亮：道德（德性）其实是一种方便，道德完全是为了方便而发明的。想想也是有道理的，许多好的品德，如善良，自己善良别人可能觉得你对他没有攻击性，给人安全感，这样容易取得别人的信任和接纳；比如孝顺，孝顺自己父母，也可能是为了为自己儿女树立榜样，将来自己的儿女可能也这样对待自己等等。所以，那些标榜自己品德高尚的正人君子，没必要太骄（孤）傲，其实也是某种程度的利己之人。归根到底，人类的许多行为都是为了追求利己的。有的人利己能双赢，得到赞颂，成为高德之人；有人利己会损人，成为卑鄙小人，罪人。仓廪足而知礼节。只有神、上帝才可能只为别人不为自己。为什么捏？上帝啥都不缺，所以他可以啥都给。而我们凡人，总有这样那样的缺憾，所以不可能完全无我而利他。不要把别人想的那么坏，也不要把自己想的那么好，都是凡人而已。</p><hr><p> 摘抄：  </p><blockquote><p> 一缕迷路的阳光大概是出于好奇，朝我的屋子里瞥了一眼。</p><p> 爱情总要过去的，而差异总是会保存下来。</p><p> 人类一切美德的基础乃是最深刻的利己主义。一件事越是合乎道德，其中的利己成分就越多。</p></blockquote><hr><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center>END</center></h1>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《遥远的救赎主》（豆豆著）读后感</title>
      <link href="/2019/05/25/%E9%81%A5%E8%BF%9C%E7%9A%84%E6%95%91%E8%B5%8E%E4%B8%BB%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2019/05/25/%E9%81%A5%E8%BF%9C%E7%9A%84%E6%95%91%E8%B5%8E%E4%B8%BB%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p><strong> 阅读后的反思（一） </strong><br><strong> 这部作品提出的得救之道是什么？</strong><br>&ensp;&ensp;&ensp;&ensp; 这部作品有大段篇幅对神、天道、得救之道进行讨论，这样的讨论让人感觉很高深、玄幻。要回答得救之道是什么，可以先回答一下谁需要得救？<a id="more"></a> 仅就这部作品而言，邓世杰等烧友以及王庙村的农民需要得救，需要从水深火热的贫困县的贫困村中发家致富。那么这些人是如何寻求得救之道呢？村民信基督教，说信耶稣便得救了。烧友信高人，信高人便得救了。从而引申出本书的核心话题：文化属性。中国的文化属性充斥着救主文化特征。什么事都要去依靠 xx、投靠 xx，靠一两个英雄拯救，靠贤明君主布施、恩宠，无非就是想要破格获取。丁元英通过表面上平实无奇的招数为王庙村、烧友们上了一堂“得救之道到底是什么”的教学实践课。<br>&ensp;&ensp;&ensp;&ensp; 作者（豆豆）的观点是：“能否得救完全取决于自己，从来没有救世主，要想得救就要实事求是。如果一定要讲救世主的话，那么符合和代表客观规律的文化就是救世主。”<br>&ensp;&ensp;&ensp;&ensp; 以下是文章摘抄，可能作为这个问题的回答：</p><blockquote><p>&ensp; 民无主，并非真的无主，而是没有对客观规律认识的主，只依赖强者道德的主，即为“你要为我做主”。<br>&ensp; 翻开历史，找不到一处救世主救人的记录。从来都是救人的被救了，被救的救了人。从来没有什么救世主，那么我们脆弱的人类该怎样在这个孤独的星球立足？认识客观规律并掌握它，便成了自己的救世主。</p></blockquote><p><strong> 如何看待芮小丹的结局？</strong><br>&ensp;&ensp;&ensp;&ensp; 如果她不自杀，结局可能有几种：<br>&ensp;&ensp;&ensp;&ensp;1）背负残缺的身子过一生；<br>&ensp;&ensp;&ensp;&ensp;2）被追授为烈士，成为人们敬仰和怜悯的对象。<br>&ensp;&ensp;&ensp;&ensp; 如果只是身体中了一颗子弹，小丹必不会自杀。然而她已经是一个残废、面目全非之人，失去了美丽的面容和独立的行动能力。这些都可能使她因自卑离开丁元英，也可能被丁元英抛弃。要靠别人才能活下去，失去自主、自立。自主、自立对于小丹来说是生命赖以维持下去的根本动力。<br>&ensp;&ensp;&ensp;&ensp; 丁元英的回答是：“因为她认为自己没用了”。当活着只是给家庭、社会增加负担之外毫无意义，那么对于小丹这种明心见性的女人来说，自杀可能是自觉的选择。当发觉自己没有价值了，是否能有勇气结束自己的生命？当生则生，当死则死。这就是客观规律，没有一点道德情义可讲。<br>&ensp;&ensp;&ensp;&ensp; 这一点很像笔者今年英语口语课上的临终关怀话题。其中一个观点是人需要在清醒、没病没灾的情况下提前计划自己完全失去意识时是否继续救治，是否要在处于植物人状态下仍然维持生命。如果活下去没有意义，那么潇洒转身离开才是明智选择，自己不受罪，他人也不受罪。</p><p><strong> 如何理解“神即道，道法自然，如来”？</strong><br>&ensp;&ensp;&ensp;&ensp; 救世主，也就是所谓的神，就是代表客观规律的文化（道），道来自于客观（自然），不以人的意志为转移，一切以时间、地点和条件为转移。  </p><blockquote><p>&ensp; 原来能说老实话、能办老实事的人就是神，能做到实事求是就是神话。实事求是，就是按照客观规律说话、办事。</p></blockquote><p><strong> 《遥远的救世主》这个题目与文章主题有何关联？</strong><br>&ensp;&ensp;&ensp;&ensp; 遥远的救世主、天国的女儿，这些提法都有意或无意地暗示人们根本没有什么救世主，要把自己头脑中的救主思想改造，学习并掌握客观规律，自己拯救自己。</p><p><strong> 文化属性是什么？</strong><br>&ensp;&ensp;&ensp;&ensp; 任何对象（object）都有属性（attribution)，人类社会也不例外。文化属性，这个词乍看有点虚空、有点大有、点泛。这东西有什么用呢？竟然还有人关注这个东西。人的思维层次不同，关注的问题的内容和角度也不一样。这部小说在给读者传达一种思想：掌握了文化属性就掌握了透视人类社会的方法。所以你没意识的东西并不一定代表不存在，你没意识到的东西很可能正是你现在或者将来问题的答案和钥匙。</p><blockquote><p>&ensp; 支配人的价值取舍行为的那个东西就是主，就是文化属性。<br>&ensp;&ensp; 作者并未直接给出文化属性的定义。而是说它包含了什么：<br>&ensp; 透视社会依次有三个层面：技术、制度和文化。小到一个人，大到一个国家，任何一种命运归根到底都是文化属性的产物。文化有强弱之分。强势文化造就强者，弱势文化造就弱者，这是规律，也可以理解为天道，不以人的意志为转移。</p></blockquote><p><strong> 强势文化与弱势文化及其在国人身上的体现？</strong></p><blockquote><p>&ensp; 强势文化就是遵循事物规律的文化；弱势文化就是依赖强者的道德，期望破格获取的文化，也就是救世主文化。强势文化在武学上被称为秘笈，而弱势文化由于易学、易懂和易用成了流行品种。  </p></blockquote><p>&ensp;&ensp;&ensp;&ensp; 体现：“出门靠朋友，在家靠父母”、“官本位”、“送礼、走后门”、“酱缸文化”。</p><p><strong> 如何理解透视社会的三个层次？</strong><br>&ensp;&ensp;&ensp;&ensp; 做人也好、工作也好，都有层次之说。王国维所说人生三境界，佛教所说悟道三境界，独孤求败武术精进的几层境界。事物是有层次之分的，由易到难，由浅入深。如果不求上进，不思进取，那么可能永远都是井底之蛙，原地踏步。<br>&ensp;&ensp;&ensp;&ensp; 透视社会的三个层次：技术、制度和文化。技术，代表了这个社会的生产力水平，制度代表了这个社会的运行方式，而文化代表了这个社会的价值取向。技术、制度都是文化的产物，要想改变技术、制度，可能需要从文化属性的改变入手，毕竟降维打击比较容易。</p><p><strong> 丁元英为什么最后能够逼迫乐圣公司合作？</strong><br>&ensp;&ensp;&ensp;&ensp; 一种思考方式：<br>&ensp;&ensp;&ensp;&ensp; 从狼嘴里夹肉，杀富劫贫 &lt;——以子之矛攻子之盾，逼迫对方合作 &lt;——先给对方一个陷阱（格律诗的国际名声也给乐圣以甜头，打价格战），时机的选择，以扩大最大影响力为目的（音响博览会）&lt;——王庙村生产产品 &lt;——王庙村现状 </p><p>&ensp;&ensp;&ensp;&ensp; 丁元英不做格律诗股东让欧阳雪掌握股权的考虑：<br> 丁元英预料到公司会与乐圣打官司，有可能会陷入危机，这时小农的“自保意识、求生本能”会使公司陷入四分五裂的境况，如果让被恐惧吓到的人掌握公司的决定权，那么公司必定破产无疑。所以要选一位对自己信赖的人做董事长。</p><p><strong> 杀富济贫为什么救不了贫？救主文化在国人、中国历史上的体现。</strong><br>&ensp;&ensp;&ensp;&ensp; 杀富富不去，济贫贫不离。因为贫富都是文化属性的产物，不改变思想，不去认识客观规律，那么人还是会走老路。特别是穷人，还是陷入等待救主的思维。</p><blockquote><p>&ensp; 弱势群体得到的输血越多，自身的造血功能就越差，越接近死亡。不改变造血功能，就解决不了造血问题，就谈不上救济。</p></blockquote><p><strong> 对大爱不爱的理解。</strong><br>&ensp;&ensp;&ensp;&ensp; 丁元英去五台山上寻求一个心理安慰，大师一句话给他吃了一颗定心丸：大爱不爱。爱有时候也是一种毒药，它让受让者破格获取，灰姑娘的故事等等，最终不会让受让者拥有造血功能。道德也是这样。从根本上说，人性中包含着兽性，现代社会像一个钢筋水泥的丛林，在丛林里就有丛林法则：弱肉强食，优胜劣汰。仅仅靠道德和爱来给弱势群体输血是不能让他们在这个丛林里存活的。得让他们在不断地生存斗争中磨练出一套认识客观规律和掌握客观规律的本事，才是大爱。</p><blockquote><p>&ensp; 天地不仁以万物为刍狗，圣人不仁以百姓为刍狗是也。不要用道德来谴责强者和怜悯弱者。<br><strong> <center>END</center></strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书思考 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
