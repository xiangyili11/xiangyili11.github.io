<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>R 语言绘图——为层次聚类图及树状图添加 side bar</title>
      <link href="/2020/04/19/R%E8%81%9A%E7%B1%BB%E5%9B%BE%E6%B7%BB%E5%8A%A0side%20bar/"/>
      <url>/2020/04/19/R%E8%81%9A%E7%B1%BB%E5%9B%BE%E6%B7%BB%E5%8A%A0side%20bar/</url>
      
        <content type="html"><![CDATA[<p>摘要：介绍一种对热图（heatmap)和树状图（dendrogram）添加注释信息条（side bar)的方法。<a id="more"></a></p><p>聚类分析作图往往包含热图（heatmap)和树状图（dendrogram）。热图用来展示每个样本点数值大小和聚集模式。树状图用来表示样本之间以及变量之间的距离远近（或者相似性大小）。R 官网目前提供了至少 45 个可以绘制热图的包（packages），其中比较常见的、可以添加行列注释信息条的聚类作图包有 <a href="https://cran.r-project.org/web/packages/pheatmap/index.html" target="_blank" rel="noopener">pheatmap</a>、<a href="https://cran.r-project.org/web/packages/gplots/index.html" target="_blank" rel="noopener">gplots</a> 等等。以下简单介绍一下对热图（heatmap)和树状图（dendrogram）添加注释信息条（side bar)的方法（以 mtcars 数据集为例）。</p><h4 id="树状图 - 热图 -side-bar"><a href="# 树状图 - 热图 -side-bar" class="headerlink" title="树状图 + 热图 +side bar"></a>树状图 + 热图 +side bar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library(gplots)# 导入 R 包</span><br><span class="line">data(mtcars)# 导入示例数据</span><br><span class="line">x &lt;- as.matrix(mtcars)#gplots 要求输入 numeric matrix，所以要转化为数量矩阵</span><br><span class="line">rc &lt;- rainbow(nrow(x),start=0, end=.3)# 用于绘制 side bar，给每一个行名赋一种颜色</span><br><span class="line">cc &lt;- rainbow(ncol(x), start=0, end=.3)# 用于绘制 side bar，给每一个列名赋一种颜色</span><br><span class="line">hv &lt;- heatmap.2(x,RowSideColors=rc, ColSideColors=cc)# 画图</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://img2020.cnblogs.com/blog/2003015/202004/2003015-20200419150908650-247186127.png" alt></p><h4 id="树状图 -side-bar"><a href="# 树状图 -side-bar" class="headerlink" title="树状图 +side bar"></a>树状图 +side bar</h4><p>如果数据量比较大，不想显示热图部分，而只想显示树状图部分，则可以使用 <a href="https://cran.r-project.org/web/packages/dendextend/index.html" target="_blank" rel="noopener">dendextend</a> 包（仍以 mtcars 数据集为例）实现。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">library(dendextend)# 导入 R 包</span><br><span class="line">data(mtcars)# 导入数据</span><br><span class="line">dend &lt;- as.dendrogram(hclust(dist(mtcars)))</span><br><span class="line"></span><br><span class="line"># 给每种样本（汽车）赋一种颜色，这里有四种汽车类型</span><br><span class="line">car_type &lt;- rep(&quot;Other&quot;, length(rownames(mtcars)))</span><br><span class="line">is_x &lt;- grepl(&quot;Merc&quot;, rownames(mtcars))</span><br><span class="line">car_type[is_x] &lt;- &quot;Mercedes&quot;</span><br><span class="line">is_x &lt;- grepl(&quot;Mazda&quot;, rownames(mtcars))</span><br><span class="line">car_type[is_x] &lt;- &quot;Mazda&quot;</span><br><span class="line">is_x &lt;- grepl(&quot;Toyota&quot;, rownames(mtcars))</span><br><span class="line">car_type[is_x] &lt;- &quot;Toyota&quot;</span><br><span class="line">car_type &lt;- factor(car_type)</span><br><span class="line">n_car_types &lt;- length(unique(car_type))</span><br><span class="line">cols_4 &lt;- colorspace::rainbow_hcl(n_car_types, c = 70, l  = 50)</span><br><span class="line">col_car_type &lt;- cols_4[car_type]</span><br><span class="line"></span><br><span class="line"># 画图</span><br><span class="line">par(mar = c(12,4,1,1))</span><br><span class="line">plot(dend)</span><br><span class="line">colored_bars(col_car_type,dend,rowLabels=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://img2020.cnblogs.com/blog/2003015/202004/2003015-20200419151134351-797138465.png" alt></p><p>另：有时候数据量非常大，样本名称叠加到一起会糊成一片，导致看不清楚。不如去掉样本名称，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 画图</span><br><span class="line">par(mar = c(12,4,1,1))</span><br><span class="line">labels(dend) &lt;- &quot;&quot;</span><br><span class="line">plot(dend)</span><br><span class="line">colored_bars(col_car_type,dend,rowLabels=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://img2020.cnblogs.com/blog/2003015/202004/2003015-20200419151158219-2060275282.png" alt></p><p>参考资料：<br>[1] <a href="https://cran.r-project.org/web/packages/dendextend/vignettes/FAQ.html#how-to-color-a-dendrograms-brancheslabels-based-on-cluster-i.e.-cutree-result" target="_blank" rel="noopener">Frequently asked questions</a> </p><p>[2] <a href="https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html" target="_blank" rel="noopener">Hierarchical cluster analysis on famous data sets - enhanced with the dendextend package</a></p>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 MatrixEQTL 进行 eQTL mapping analysis——以 GTEx 数据库为例</title>
      <link href="/2020/04/12/MatrixEQTL/"/>
      <url>/2020/04/12/MatrixEQTL/</url>
      
        <content type="html"><![CDATA[<p>摘要：本文介绍了一种对 GTEx 数据库进行 eQTL 分析的方法。使用的主要工具包括 MatrixEQTL 和 plink。<a id="more"></a></p><p>MatrixEQTL 是一个快速有效的 cis/trans eQTL mapping 分析工具，被 <a href="https://www.gtexportal.org/" target="_blank" rel="noopener">The Genotype-Tissue Expression (GTEx)</a> 数据库用于 eQTL mapping 分析。使用 MatrixEQTL 进行 eQTL mapping 需要五个输入文件，即<a href="http://www.bios.unc.edu/research/genomic_software/Matrix_eQTL/Sample_Data/SNP.txt" target="_blank" rel="noopener">SNP.txt</a>（snpmatrix 文件，行名为样本名称，列名为 snpid）， <a href="http://www.bios.unc.edu/research/genomic_software/Matrix_eQTL/Sample_Data/GE.txt" target="_blank" rel="noopener">GE.txt</a>（基因表达量文件，行名为样本名称，列名为基因或者转录本名称）， <a href="http://www.bios.unc.edu/research/genomic_software/Matrix_eQTL/Sample_Data/Covariates.txt" target="_blank" rel="noopener">Covariates.txt</a>（协变量文件，行名为样本名称，列名为协变量名称），<a href="http://www.bios.unc.edu/research/genomic_software/Matrix_eQTL/Sample_Data/geneloc.txt" target="_blank" rel="noopener">geneloc.txt</a>（基因位置文件，各列的含义分别是基因名称、基因所在染色体编号、基因起始位置和基因结束位置），<a href="http://www.bios.unc.edu/research/genomic_software/Matrix_eQTL/Sample_Data/snpsloc.txt" target="_blank" rel="noopener">snpsloc.txt</a>（snp 的物理位置文件，各列含义分别为 snpid、所在染色体名称、物理位置）。</p><h3 id="SNP-txt 文件的准备"><a href="#SNP-txt 文件的准备" class="headerlink" title="SNP.txt 文件的准备"></a>SNP.txt 文件的准备 </h3><p> 需要准备的数据：.vcf.gz 或者.vcf 文件。</p><p><strong>第一步：获取重复 snpid</strong><br>由于第七版的 GTEx 基因型数据存在 snpid 重复的情况，为了准确计算 maf，所以需要去重。</p><p>具体方法一：<br>① vcf 文件转化为 ped 和 map 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink --vcf file.vcf --recode --out file</span><br></pre></td></tr></table></figure><p>或者  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink --vcf file.vcf --recode --out file</span><br></pre></td></tr></table></figure><p>输出：file.ped  file.map</p><p>②基于得到的 file.map 文件，得到重复的 snpid，存储到 plink.dupvar 文件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -f 2 file.map | sort | uniq -d &gt; plink.dupvar</span><br></pre></td></tr></table></figure><p>具体方法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink --file file.vcf --list-duplicate-vars ids-only suppress-first</span><br></pre></td></tr></table></figure><p>输入：file.vcf<br>输出：plink.dupvar（重复的 snpid 文件）</p><p>注：方法一和方法二的区别是方法二更准确，其对于每一个重复的项保留了一项（suppress-first），而方法一删除了全部重复项。</p><p><strong>第二步：过滤 snpid 和样本 id</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink --vcf .vcf.gz --recode --out .name --keep .sampleid --missing --freq --maf 0.02 --exclude plink.dupvar</span><br></pre></td></tr></table></figure><p>输入：<br>.vcf.gz，原始 vcf 文件；<br>.sampleid，用户想保留的 sampleid；<br>plink.dupvar，用户想过滤掉的 snpid。  </p><p>输出：<br>.name.frq，   所有 snpid 的等位基因（A1，A2)以及 MAF；<br>.name.lmiss，  所选样本的 snpid 确实情况；<br>.name.imiss，   每个样本基因型缺失情况；<br>.name.ped，更新后的 ped 文件；<br>.name.map，更新后的 map 文件。  </p><p><strong>第三步：计算 snp 矩阵</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --gzvcf .vcf.gz --012 --out .name --keep .sampleid --maf 0.02 --exclude plink.dupvar</span><br></pre></td></tr></table></figure><p>输入：<br>.vcf.gz，原始 vcf 文件；<br>.sampid，用户想保留的样品 id；<br>plink.dupvar，用户想过滤掉的 snpid。  </p><p>输出：<br>name.012，snpmatrix（样本数 *snpid 数），纯数字矩阵，只有行索引（是样本 id 在原始.vcf.gz 文件中的索引号），没有列索引。与 MatrixEQTL 要求的输入文件 SNP.txt 正好相反，所以后面需要转置；<br>name.012.pos，snpid 所在的染色体及物理位置；<br>name.012.indv，样本 id。  </p><p><strong>第四步：snp 矩阵转置 </strong><br> 因为 SNP.tx 有格式要求，所以行名必须是 snpid，列名必须是样本名称。因此需要删除 name.012 的第一列（即索引号），然后转置。</p><p>① 快速删除第一列 Index  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123; $1=null;print &#125;&apos; name.012 &gt; name_del0.012</span><br></pre></td></tr></table></figure><p>②添加 sampleid  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste name.012.indv name_del0.012  &gt; name_del0.012_indv.txt</span><br></pre></td></tr></table></figure><p>③ 快速添加行 snpid<br>首先从.map 文件中获得 snpid </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file | awk &apos;&#123;print $2&#125;&apos; &gt; snpid.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ID&quot; &gt; snpid1.txt ; cat snpid.txt &gt;&gt; snpid1.txt</span><br></pre></td></tr></table></figure><p>注：snpid.txt 即为去除重复后的 snpid，从 name.map 中获得。</p><p>④合并多行为一行 <br> 可以用很多方法实现该目的，在此以 python 脚本 sipid_2_oneline.py 为例，输入文件为上述 snpid1.txt，输出文件为一行 snpid，以 tab 符分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from sys import argv</span><br><span class="line">script,input,output = argv</span><br><span class="line"></span><br><span class="line">with open(output,&quot;w&quot;) as f:</span><br><span class="line">    with open(input) as f1:</span><br><span class="line">        for line in f1.readlines():</span><br><span class="line">            f.write(line.strip()+&quot;\t&quot;)</span><br><span class="line">    f.write(&quot;\n&quot;)</span><br><span class="line">```    </span><br><span class="line">``` </span><br><span class="line">python sipid_2_oneline.py input output    </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">⑤添加 snpid 并转置</span><br></pre></td></tr></table></figure><p>cat snpid1.txt  name_del0.012_indv.txt&gt; genotype.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>awk ‘{i=1;while(i &lt;= NF){col[i]=col[i] $i “ “;i=i+1}} END {i=1;while(i&lt;=NF){print col[i];i=i+1}}’ genotype.txt | sed ‘s/[\t]*$//g’ &gt; genotype_transpose.txt<br>```</p><h3 id="snp-loc-txt 准备和 gene-loc-txt 准备"><a href="#snp-loc-txt 准备和 gene-loc-txt 准备" class="headerlink" title="snp_loc.txt 准备和 gene_loc.txt 准备"></a>snp_loc.txt 准备和 gene_loc.txt 准备 </h3><p>1）snp 位置（snp position)<br> 从.map 中获得，只需调换位置即可。</p><p>2）基因或者转录本位置（gene position）<br>从 <a href="http://asia.ensembl.org/biomart" target="_blank" rel="noopener">ensembl</a> 网站下载。</p><h3 id="GE-txt 文件准备和 Covariate-txt 文件准备"><a href="#GE-txt 文件准备和 Covariate-txt 文件准备" class="headerlink" title="GE.txt 文件准备和 Covariate.txt 文件准备"></a>GE.txt 文件准备和 Covariate.txt 文件准备 </h3><p> 根据实际情况准备 GE.txt，协变量文件非必需。</p><h3 id="运行 MatrixEQTL"><a href="# 运行 MatrixEQTL" class="headerlink" title="运行 MatrixEQTL"></a>运行 MatrixEQTL</h3><p>将上述五个（或者四个，不需要 covariate.txt 文件）准备好后，直接使用 MatrixEQTL 的 <a href="http://www.bios.unc.edu/research/genomic_software/Matrix_eQTL/R.html#cis" target="_blank" rel="noopener"> 示例代码 </a> 进行 eQTL 分析。</p><p><strong>参考资料：</strong><br><a href="https://cloud.tencent.com/developer/article/1476750" target="_blank" rel="noopener">R 语言实现 eQTL 分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eQTL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人皮论语》读后感</title>
      <link href="/2019/12/24/%E4%BA%BA%E7%9A%AE%E8%AE%BA%E8%AF%AD%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2019/12/24/%E4%BA%BA%E7%9A%AE%E8%AE%BA%E8%AF%AD%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>尽信书则不如无书 </strong><br> 尽信书则不如无书其实是“尽信《书》，不如无《书》”，出自《孟子·尽心下》。这里的书原指《尚书》。<a id="more"></a>这句话的意思就是读书的时候不要拘泥于书本或者迷信书本。《人皮论语》讲述了世界上绝无仅有的古本论语《孔壁论语》历尽劫波最终在劫难逃的故事，按照小说的说法是自汉代武帝以来教化人们的《论语》是被阉割和歪曲了的《论语》。这本小说读起来酣畅淋漓，旁征博引，虽然当作小说和故事书来读，但是作者对于论语的来历和版本的分析确实有一定道理。<br>除了这些人为的因素外，还有一些不可抗力因素使得古籍真本难以面世。听说过一个说法，因为汉代以前书籍的主要载体是竹简，竹简之间多用麻绳连结，时间一久，麻绳腐烂，竹简散乱，从而使得文章字句的顺序难以辨识，导致后人编撰的书籍与古籍不一样。还有一种比较阴暗的猜测，因为有些知识就像绝世秘籍，得之小则有益身心，大则雄霸武林。传子传孙不外传，但是迫于某些原因不得不传，那就索性修改某些关键部分，让得到这些“秘籍”的人仍不得要领甚至事倍功半。</p><p><strong>牺牲精神 </strong><br>《人皮论语》小说快结束了才点题，原来是通过豪侠朱世安的纹身来传送古本论语。在朱世安身上真正体现出古人“一诺千金”、“季布一诺”的精神，对比当今社会诚信的现状……。朱安世为一句承诺、一份托付而不惜历尽艰难万险，跋山涉水，历经九死一生。最后不惜牺牲自己，使用残缺之躯来传送“论语”，不幸的是此论语仍然是“假”论语。可悲可恨可叹！<br> 司马迁也是这本书的主要人物之一，他胸怀大志，誓要通古今之变，成一家之言。因为仗义执言而触怒皇帝，惨遭宫刑。他本来可以选择一死了之，因为士可杀不可辱。但是想到自己未竟的事业，心有不甘，最终选择为理想而生。从网上搜索了司马迁的生平，发现没有记载其明确的逝世日期，可以想象完成《史记》后的司马迁晚年过着怎样的生活：深藏功与名，千秋功过留予后人评说，说的就是司马迁这样的人吧。司马迁得偿所愿，此生应无憾吧！想起来《梦不死》里面的歌词：为梦而生，为梦而活，天空海阔……。为理想而死得人确实伟大，那么为理想而生的人也很伟大吧？</p><p>摘抄：</p><blockquote><p>抛下世间所爱，一尝心中之恨，值得吗？<br>威之以杀，令人丧胆；饵之以禄，使人骨酥。<br>宁要真骂，不要假笑。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学研究是什么</title>
      <link href="/2019/12/20/%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2019/12/20/%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>摘要：最近读了一本优秀的数学科普书《费马大定理》，该书用生动的笔触描写了费马大定理的前世今生，非常值得阅读。这本书对科学（数学）研究是什么的描述也非常有意思，能够给人以启迪。<br><a id="more"></a></p><p>小时候上课，老师们喜欢问长大以后要做什么，许多天真无邪的小学童们都异口同声地说长大了要当科学家。科学家、科学研究，多么神圣的职业和字眼啊！那时候科学家的形象往往是穿着白大褂、专心致志地摇晃试剂的白胡子谢顶的老爷爷。总喜欢想幻着自己在实验室摇晃试剂，观察显微镜的场景。现在自己终于算是实现了自己儿时的梦想，在大学实验室里板砖，接受专业的科学研究训练。才发现自己对科学研究理解得多么肤浅。<br>我现在理解的科学研究工作是以解决本领域得一个重要的（或者自己感兴趣的）科学问题开始，然后着手查找文献看看这问题已经取得哪些进展，然后基于前人的成果提出假设，设计研究方案，准备材料，开始试验（或者反复试验），得到有意义的试验结果后，整理成文发表传播。看似流程简单，但是其中任何一步出现问题就要推倒重来，反反复复，翻来覆去。不断提出假设，编写脚本，调试参数，总是得到非常“怪异”的结果，然后从头再来……。这时候终于体会到科学研究的艰难，偶尔会有放弃的念头出现，这时自己总会给自己打气：give yourself three months before you give up。然后算算三月之期的时间什么时候到……</p><p>爱迪生（的团队？）经过数千次试验，尝试数千种材料，找到了合适的灯丝材料。爱迪生是屡败屡战的代表，也从侧面反映出科学研究的艰辛。但不是每个人都能做到在科学的未知之境、黑暗里一往无前、不失勇气地摸索。到底科学研究是什么，科学研究的黑暗期该如何面对。我在 <a href="https://book.douban.com/subject/20494401/" target="_blank" rel="noopener">《费马大定理》</a> 里看到一段话似乎可以作为一个回答：</p><blockquote><p>怀尔斯借用穿越一幢漆黑的未经检测的大厦的经历来描述他在做数学研究时的感受。“设想你进入大厦的第一个房间，里面很黑，一片漆黑。你在家具之间跌跌撞撞，但是逐渐搞清楚了每一件家具所在的位置。最后，经历 6 个月或者再多一些的时间，你找到了电灯开关，打开了灯。突然整个房间充满光明，你能确切地明白你在何处。然后，你又进入下一个房间，又在黑暗中摸索了 6 个多月。一次，每一次这样的突破，尽管有时候只是一瞬间的事，有时候需要一两天，但它们实际上是这之前的许多个月里在黑暗中跌跌撞撞的最终结果，没有前面的这一切它们是不可能出现的。</p></blockquote><p>小时候无知，梦想当科学家是因为：“成功的花儿，人们只惊羡它现时的美丽”，是羡慕科学家的成功光环和荣耀，现在初入科学研究之门，才真正体会到“当初它的芽儿浸透了奋斗的泪水，洒遍了牺牲的细雨”，体会到有价值的科学研究的道路从来都不是一帆风顺的，想起马克思说过的一句话：“在科学上没有平坦的大道，只有不畏劳苦沿着陡峭山路攀登的人，才有希望达到光辉的顶点”。</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h3>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DrugBank 源文件 full_database.xml 文件的数据处理</title>
      <link href="/2019/12/17/DrugBank%E6%BA%90%E6%96%87%E4%BB%B6full_database.xml%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2019/12/17/DrugBank%E6%BA%90%E6%96%87%E4%BB%B6full_database.xml%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>摘要：DrugBank 是药物研究领域非常重要的数据库，其数据提供免费下载，但是数据结构对普通研究人员很不友好，为 xml 格式的文件，需要进一步整理才能得到结构清晰的数据，因此本文将据介绍一种将 DrugBank full_database.xml 文件整理成结构化文件的方法。<br><a id="more"></a></p><p><a href="https://www.drugbank.ca/" target="_blank" rel="noopener">DrugBank</a>数据库是一个重要的药物理化属性数据库，由加拿大卫生研究院、亚伯达省创新 - 健康解决方案和代谢组学创新中心（TMIC）提供技术支持，目前（2019 年）整合了一万多种药物的生物信息学和化学信息学资源，并提供了详细的药物数据与药物靶标信息及其作用机制的信息，包括药物化学、药理学、药代动力学、ADME 及药物相互作用信息。利用该数据库网站可方便地查询药物的多种信息。该数据库允许研究人员免费下载网站数据。</p><p>DrugBank 原始数据是 full_database.xml，因此需要进一步转化成容易处理的结构化文本格式（.txt 或者.csv)。这里记录一种处理方法供参考。以获取小分子药物的名称、所处临床阶段、药物描述信息、药物适应症为例。<br>数据：2018 年 7 月 DrugBank 网站下载的 <a href="https://pan.baidu.com/s/1JLKgbNl-JvVA51ulR--t1Q" target="_blank" rel="noopener">full_data.xml</a>（百度网盘提取码：at9e）文件<br> 工具：Python3 及其 pandas、untangle 库 <br> 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import untangle# 导入该库用以将 XML 文件映射为一个 Python 对象，使相同名字的元素值组成数组</span><br><span class="line">import pandas as pd# 导入 pandas 库用以存储结果数据</span><br><span class="line"></span><br><span class="line"># 读取 XML 文件</span><br><span class="line">drugbank_xml = untangle.parse(&quot;F:/00_DrugRepo_database_predicTool/Drugbank_based/drugbank_all_full_database.xml/full_database.xml&quot;)</span><br><span class="line">df_drugbank_sm=pd.DataFrame(columns=[&quot;drugbank_id&quot;,&quot;name&quot;,&quot;cas&quot;,&quot;group&quot;,&quot;description&quot;,&quot;indication&quot;])</span><br><span class="line"></span><br><span class="line">i=0</span><br><span class="line">#drugbank_xml.drugbank.drug,drugbank_xml 是对象名，  </span><br><span class="line">#drugbank 是 xml 文件最外层的标记名称（根元素），  </span><br><span class="line">#drug 是每个子元素的标记名称        </span><br><span class="line">for drug in drugbank_xml.drugbank.drug:# 对每一个子元素进行循环</span><br><span class="line">    drug_type= str(drug[&quot;type&quot;])# 获取每个子元素的 &quot;type&quot; 属性</span><br><span class="line">    </span><br><span class="line">    # select for small molecule drugs，“type”属性为小分子药物的英文名称</span><br><span class="line">    if drug_type in [&quot;small molecule&quot;, &quot;Small Molecule&quot;, &quot;Small molecule&quot;]:    </span><br><span class="line">        </span><br><span class="line">        #Get drugbank_id，获取 drug ID 属性</span><br><span class="line">        for id in drug.drugbank_id:</span><br><span class="line">        #由于 drugbank 中每个药物有多个不同的 ID，这里选取 primary ID</span><br><span class="line">            if str(id[&quot;primary&quot;])==&quot;true&quot;:</span><br><span class="line">                df_drugbank_sm.loc[i, &quot;drugbank_id&quot;]=id.cdata# 获取 ID 值，下同</span><br><span class="line">        </span><br><span class="line">        #Drug name，获取药物名称</span><br><span class="line">        df_drugbank_sm.loc[i,&quot;name&quot;]=drug.name.cdata</span><br><span class="line">        </span><br><span class="line">        #Drug CAS，获取药物 CAS number</span><br><span class="line">        df_drugbank_sm.loc[i, &quot;cas&quot;]=drug.cas_number.cdata</span><br><span class="line">        </span><br><span class="line">        #Drug group，获取药物所处的临床阶段</span><br><span class="line">        groupcdata = &quot;&quot;</span><br><span class="line">        for group in drug.groups.group:</span><br><span class="line">            groupcdata = groupcdata+group.cdata+&quot;,&quot;</span><br><span class="line">        df_drugbank_sm.loc[i, &quot;group&quot;]=groupcdata</span><br><span class="line">        </span><br><span class="line">        #Drug indication，获取药物适应症</span><br><span class="line">        df_drugbank_sm.loc[i, &quot;indication&quot;]=drug.indication.cdata</span><br><span class="line">        </span><br><span class="line">        #Drug descriptions, 获取药物的描述信息</span><br><span class="line">        df_drugbank_sm.loc[i, &quot;description&quot;]=drug.description.cdata</span><br><span class="line">        </span><br><span class="line">        i=i+1</span><br><span class="line"># 将结果写入文件</span><br><span class="line">df_drugbank_sm.to_csv(&quot;drugbank_drugName_group_description_indication.txt&quot;,sep=&quot;\t&quot;,index=False)</span><br></pre></td></tr></table></figure><p>另：该代码只用于少量信息的提取，如果还需要药物的其他信息，可以直接在 for 循环里添加语句，找到对应的子元素名称（也就是 drugbank 里面的条目名称），依葫芦画瓢即可。<br>参考资料：<a href="https://mp.weixin.qq.com/s/1meZwdQWbdygZt_Qz7a7pA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1meZwdQWbdygZt_Qz7a7pA</a></p>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DrugBank </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双聚类及多聚类的概念</title>
      <link href="/2019/12/15/%E5%8F%8C%E8%81%9A%E7%B1%BB%E5%8F%8A%E5%A4%9A%E8%81%9A%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/12/15/%E5%8F%8C%E8%81%9A%E7%B1%BB%E5%8F%8A%E5%A4%9A%E8%81%9A%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>摘要：聚类是一种重要的无监督学习算法。物以类聚，人以群分。其主要基于样本之间的相似性大小进行种类的划分。根据聚类方法的不同，可以将聚类算法分为单聚类、双聚类（biclustering)和多聚类 (multiview clustering) 等等。<br><a id="more"></a><br>单聚类：即基于给定的（一个）数据集给出 <strong> 一个聚类结果 </strong>。其聚类结果是样本在全部特征下的一个分类结果。无论数据集多么复杂多元，单聚类只从<strong> 全局 </strong> 的角度给出一个分类结果。<br>R 包：[stats]包的 hclust()函数与 kmeans()函数、<a href="https://cran.r-project.org/web/packages/ClusterR/index.html" target="_blank" rel="noopener">ClusterR</a>等等。</p><p>多聚类（multiple clustering）：根据 <strong> 多个不同的特征数据集 </strong>（或者多个视角,multi-views）来揭示样本的潜在结构。它的特点是根据不同的特征集可以得到<strong> 多个不同的聚类结果 </strong>。<br>R 包：<a href="https://cran.r-project.org/web/packages/IntNMF/index.html" target="_blank" rel="noopener">IntNMF</a>、<a href="https://cran.r-project.org/web/packages/NCutYX/index.html" target="_blank" rel="noopener">NCutYX</a> 等等。</p><p>双（向）聚类（Co-Clustering，BiClustering)：无论是单聚类还是多聚类，都只是在样本层面进行聚类，而双聚类能够从 <strong> 样本和特征 </strong> 两个层面对数据进行聚类，从而挖掘出数据矩阵的局部信息，也就是部分样本在部分特征下的相似性。<br>R 包：<a href="https://cran.r-project.org/web/packages/biclust/index.html" target="_blank" rel="noopener">biclust</a>、 <a href="https://cran.r-project.org/web/packages/blockcluster/index.html" target="_blank" rel="noopener">blockcluster</a>等等。</p><p>多视图双聚类（multi-view bi-clustering)： 即多聚类与双聚类的组合算法。采用多个不同特征数据集，在每个特征数据集里进行双聚类，最终通过优化算法得到一致的样本聚类结果和各自的特征数据集。<br>R 包：<a href="https://cran.r-project.org/web/packages/mvc/index.html" target="_blank" rel="noopener">mvc</a>、<a href="https://cran.r-project.org/web/packages/mvcluster/index.html" target="_blank" rel="noopener">mvcluster</a>等等。</p><p>参考文献：<br>[1]王星. 基于矩阵分解的多聚类算法研究[D]. 西南大学,2019.</p>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载——博士这五年（李沐）</title>
      <link href="/2019/10/13/%E5%8D%9A%E5%A3%AB%E8%BF%99%E4%BA%94%E5%B9%B4/"/>
      <url>/2019/10/13/%E5%8D%9A%E5%A3%AB%E8%BF%99%E4%BA%94%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<p>摘要：以前听人说，把知识比作一个圆，圈内的就是人类已知的知识，那么圈外无穷无尽的则是未知之境。又听人说过，本科毕业要求会用别人的方法重复解决别人的问题，硕士毕业要求会用别人的方法解决自己的研究问题，而博士毕业要求会创造方法解决自己的研究问题。让我们看看一个有理想、有情怀的博士是怎样度过博士阶段的。<br><a id="more"></a></p><h3 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言</h3><p>12 年 8 月提着一个行李箱降落在匹兹堡机场。没找住的地方，也不知道 CMU（Carnegie Mellon University）应该怎么去。对未来一片迷茫，但充满乐观。 现在，刚完成了博士期间最后的一场报告，在同样的机场，不过是在等待离开的航班。</p><p>回想过去的五年，是折腾的五年，也是自我感悟和提升的五年。这里我尝试记录这五年主要做过的事情和其中的感想，希望对大家有所启发。</p><h3 id="第 0 年：3-11-8-12"><a href="# 第 0 年：3-11-8-12" class="headerlink" title="第 0 年：3/11-8/12"></a>第 0 年：3/11-8/12</h3><p>我第一次申请美国的博士是在 11 年，但拿到的 offer 并没有特别合适的导师，于是就北上投奔文渊去了。 我当时在百度商务搜索部门做广告的点击预估。具体是使用机器学习来预测一个广告是不是会被用户点击。 这时候离“大数据”这个词流行还有两年，但百度那时候的数据即使现在来看仍然是大的。我的任务是如何高效的利用数百台机器快速地在数十 T 的数据上训练出模型。</p><p>当时产品用的算法基于 LBFGS，我于是想是不是可以换个收敛更快的算法。没几天就找到个不错的，但实现上发现了各种问题，包括性能，收敛，和稳定性。而且那时有的就是一个裸的 Linux 和很老版本的 GCC，什么都是需要从头开始写。花了大量时间做系统优化，算法改动，和线上实验，最后一年后在整个广告流量上上了线。</p><p>现在再回顾会觉得整个一年时间都在打磨各种细节上，有时候为了 5% 的性能提升花上上千行代码。这些都导致算法过于复杂，有过度设计之嫌。但深入各个细节对个人能力提升很大，而且很多遇到的问题成为了之后研究方向的来源。一些算法上的思考曾写在这里，当时候深度学习刚刚出来，冥冥中觉得这个应该是大规模机器学习的未来，不过真正开始跟进是好几年以后了。</p><p>11 年 12 月中的时候突然心血来潮随手把材料重新寄了一遍，就选了 CMU 和 MIT，结果意外收到了 CMU 的 offer。有天在百度食堂同凯哥（余凯）和潼哥（张潼）吃饭，我说收了 CMU offer，在纠结去不去。他们立马说去跟 Alex Smola 啊，他要加入 CMU 了，我们给你引荐下。</p><p>记得是离开的前一天才开始打包行李，早上去公司开完会，中午离职，跟小伙伴打招呼说出个国，然后就奔机场了。那天北京天气特别好，完全不记得前一天雾霾刚爆了表。</p><h3 id="第一年：9-12-8-13"><a href="# 第一年：9-12-8-13" class="headerlink" title="第一年：9/12-8/13"></a>第一年：9/12-8/13</h3><p>第一年的主要事情是熟悉环境和上课。CMU 课程比较重，博士需要学 8 门课，每门课工作量巨大。而且要求做两门课助教，做助教比上课更累。</p><p>这一年上的课中对我最有用的是“高级分布式系统”。之前在上交 ACM 班的时候已经学过很多质量都还不错课，纯知识性的课程一般对我帮助不大。但这门课主要是读论文，然后大家讨论。不仅仅是关于知识，很多是对设计理念的领悟。大家知道对于系统而言，设计是一门艺术而不是科学，这是设计者审美和哲学理念的体现。同时系统界历史也是由一波又一波的潮流组成，了解历史的发展以及其中不断重复的规律非常有意义。</p><p>那年这门课上课老师是 Hui Zhang（神人之一，20 多岁就在 CMU 任教了，学生包括了 Ion Stoica，他是 Spark 作者 Matei 的导师），他有非常好的大局观，对于“Why”这个问题阐述非常到位。我是通过这门课才对分布式系统有了比较清晰的认识。两年之后我偶然发现我的一篇论文也在这门课的阅读列表里了，算是小成就达成 。</p><p>除了上课，更重要的是做研究。我去 CMU 的时候 Alex 那时还在 Google，而且没经费，所以把我丢给了 Dave Andersen。于是我有了两个导师，一个做机器学习，一个做分布式系统。</p><p>前面半年都是在相互熟悉的过程。我们每周会一起聊一个小时。前半年因为 Alex 不在，所以我们只能视频。Alex 那边信号经常不好，而且他有德国和澳大利亚口音，外加思维跳跃，经常我听不懂他说啥只能卖萌傻笑。还是靠着 Dave 不断的打字告诉我 Alex 说了什么才度过了前几次的会。</p><p>两个导师风格迥异。Alex 是属于反应特别快，通常你说一点，他已经想好了接下来十点，要跟上他节奏很难。一般抛出问题的时候他就想好了好几个解决方法。这时候要证明自己的想法比他的更好不容易，需要大量的沟通和实验数据支撑。我想我大概是花了两年证明了在某些方向上我的方案一般更好，所以这时候他就不那么 hands-on 了。</p><p>Dave 不会给很多想法，但会帮助把一个东西理解透，然后讲得很清楚。因为我研究方向主要是机器学习上，基本上前两年基本都是我在教 Dave 什么叫机器学习，而且是尽量不用公式那种教法。</p><p>我的第一个研究工作是关于如果划分数据和计算使得减少机器学习求解中的网络通讯量。Alex 体现了他的强项，几分钟就把问题归纳成了一个优化问题，然后我们三各自提出一个解法。我做了做实验发现 Dave 的算法更好。接下来两个月把算法做了很多优化，然后又做了点理论分析就把论文写了。</p><p>可惜这个想法似乎有点超前，虽然我们一遍又一遍的改进写作，但投了好几个会审稿人就是不理解，或者觉得这个问题不重要。那个时候学术界已经开始吹嘘“大数据”，但我觉得其实大部分人是不懂的，或者他们的“大数据”仍然是几个 GB 的规模，拷 U 盘需要十来分钟的那种。</p><p>这是我在 CMU 的一个工作，我觉得挺有用，但却是唯一没能发表的。</p><p>当时跟我坐同一个办公室的是 Richard Peng，他做的是理论研究。我经常跟他讨论问题，然后有了些想法合作了一个工作。大体思想是把图压缩的快速算法做到矩阵的低秩近似上。这个工作写了三十页公式但没有任何实验，我主要当做写代码间隙的悠闲娱乐，不过运气很好的中了 FOCS。</p><p>坦白说我不是特别喜欢纯理论这种，例如在 bound 的证明中很多大量的项直接丢掉了，导致我觉得 bound 特别的近似。对于做系统的人来说，最后拼的是常数。这个工作中这种大开大合的做法我觉得很不踏实。所以我觉得以后还是应该做更实在点的东西。</p><p>在 CMU 回到了去百度前的一周七天工作无休的节奏。每周至少 80 个小时花在学校。如果累了就去健身房，我一般晚上 12 点去。不仅是我一个人，大家都很努力，例如凌晨的健身房，早 3 点的办公室，四处都可以见到中国或者印度学生。我那时候的室友田渊栋花在学校的时候比我多很多。</p><p>那一阵子有读了很多关于优化的文章。其中对我启发最大的是 Bertsekas 写于 80 年代末的那本关于分布式计算的书。此书可以认为是 MIT 控制领域黄金一代研究成果总结，换到现在仍然不过时。</p><p>受启发我转去研究异步算法，就是分布式下不保证数据的及时性来提升系统性能。我基于在百度期间做的算法，做了一些改进和理论分析，然后投了 NIPS。</p><p>投完 NIPS 就动身去了 Google Research 实习。那时候 Google Brain 成立不久，在“宇宙的答案”42 楼，包括 Jeff Dean，Geoffrey Hinton，Prabhakar Raghavan 好些大牛挤在一起，加起来论文引用率能超 80 万。</p><p>Alex 跟我说，你去读读 Jure Leskovec 的文章，学学人家怎么讲故事。我在 Google 也尝试用了些用户 GPS 数据来对用户行为建模。可是写文章的时候怎么也写不出 Jure 的那种故事感，发现自己不是那块料。这篇文章因为用了用户数据，恰逢 Snowden 让大家意识到隐私的重要性，历经艰辛删了一半结果 Google 才允许发出来。有些累觉不爱。</p><p>不过在 Google 期间我主要时间花在研究内部代码和文档上。Google 的基础架构很好，文档也很健全。虽然没有直接学到了什么，但至少是开了眼界。</p><h3 id="第二年：9-13-8-14"><a href="# 第二年：9-13-8-14" class="headerlink" title="第二年：9/13-8/14"></a>第二年：9/13-8/14</h3><p>这学期上了 Tuomas Sandholm 的机制设计，此乃另一大神，例如最近德州扑克赢了专业选手，之前开公司也卖了上亿。不过这门课我是完完全全没学懂，连承诺的课程大作业都没怎么做出来。之后的两年里我一遇到 Tuomas 他都会问下有什么进展没。我只能远远看见他就绕开。</p><p>NIPS 被拒了，发现审稿人不懂线程和进程的区别，有点沮丧。隔壁实验室一篇想法类似但简单很多的论文倒是中了 oral，所以那阵子压力很大。Alex 安慰说这种事情常有发生，看淡点，然后举了很多自己的例子。</p><p>之后想了想，一篇好文章自然需要有足够多的“干货”，或者说信息量，但一篇能被接受的文章需要满足下面这个公式： </p><p>文章的信息量 / 文章的易读性 &lt; 审稿人水平 * 审稿人花的时间 </p><p>对于机器学习会议，因为投稿量大，所以审稿人很多自然平均水平就会下降。而且很多审稿人就花半个小时到一个小时来读文章，所以公式右边数值通常是很小，而且不是我们能控制。</p><p>如果文章的信息量不大，例如是改进前面工作或者一些简单的新想法，那么公式成立的概率很大。而对于信息量大的文章，就需要努力提升易读性，包括清晰的问题设定，足够的上下文解释等等。而前面投的那篇 NIPS，以及更早的那个被拒工作，就是因为我们假设了审稿人有足够多的相关专业知识，而我们塞进了太多干货使得大家都读糊涂了。</p><p>即使对于已经发表的文章，上面那个公式同样可以用来衡量一篇论文的引用率。例如经常见到干货很多的文章没有什么人引用，而同时期的某些工作就是考虑了其中简单特殊情况结果被大引特引。</p><p>接下来的半年我主要在做一个通用的分布式机器学习框架，是想以后做实验方便些。名字就叫 parameter server，沿用了 Alex 10 年论文提出的名字。花了很多时间在接口设计上，做了好几个版本实现，也跑了些工业界级别的大规模的实验。</p><p>不过真正花了我大量时间的是在写论文上。目标是把这个工作投到 OSDI 上，OSDI 是系统界两大会之一。我们预计审稿人跟 Dave 两年前状态差不多，不会有太多机器学习和数学背景，所以需要尽量的少用公式。整整一个月就花在写论文上，14 页的文章满满都是文字和示意图。不过努力没有白费，最终论文被接受了。随后又花了好几周准备大会报告上。相对于平时花一周写论文，两三天准备报告，这次在写作和报告水平上有了很大的提升。没有放进去的公式和定理投了接下来的 NIPS，这次运气很好的中了。</p><p>有了文章后稍微心安了点可以更自由的做些事情。</p><p>寒假回了趟国，跑去百度找了凯哥和潼哥。潼哥说他最近有个想法，于是快糙猛的把实验做了然后写了篇论文投了 KDD。同时期 Alex 一个学生也把他一个一直想让我做但我觉得这个小 trick 不值得我花时间的想法投了 KDD，结果中了最佳论文。作报告那天我在的会场稀稀疏疏几个人，他们隔壁会场人山人海。这个使得好长一段时间我都在琢磨是不是还是要跟着导师走比较好。</p><p>那时凯哥在百度搞少帅计划，觉得蛮合适就加入了。这时凯哥正带着一大帮兄弟轰轰烈烈的搞深度学习，我自然也是跳坑了。试过好几个想法后，我觉得做做分布式的深度学习框架比较对胃口。我挑了 CXXNet 作为起点，主要是因为跟天奇比较熟。同时也慢慢上手跑一些 Alexnet 之类的实验。</p><p>我是因为少帅计划才开始开始做深度学习相关项目，凯哥也很支持我做开源开发回馈社会而不是只做公司内部的产品。但在少帅期间并没有做出什么对公司有帮助的事，很是惭愧。</p><h3 id="第三年：9-14-8-15"><a href="# 第三年：9-14-8-15" class="headerlink" title="第三年：9/14-8/15"></a>第三年：9/14-8/15</h3><p>回 CMU 后 Alex 看见深度学习这么火，说我们也去买点 GPU 玩玩。但我们比较穷，只能去 newegg 上掏点便宜货。这个开启了轰轰烈烈的机器折腾之旅。整个一年我觉得我都在买买买装装装上。最终我们可能就花了小几万刀攒出了一个有 80 块 GPU 的集群。现在想想时间上花费不值得，而且为了图便宜买了各种型号的硬件导致维护成本高。但当时候乐在其中。具体细节可以看这篇 blog</p><p>这一年写了很多 parameter server 代码，同时花了很时间帮助用户使用这些代码。很难说做得很成功，现在想想有几个原因。写代码时我会优先考虑性能和支持最多的机器学习算法。但正如前面的错误，忽略了代码的易读性，从而导致只有少部分人能理解代码从而做一些开发。例如我尝试让 Alex 组的学生来使用这些代码，但其中的各种异步和 callback 让他们觉得很是难懂。其次是没有人能一起审核代码接口，导致这些接口有浓浓的个人味道，很难做到对所有人都简单明了。</p><p>不过幸运的是找到一帮志同道合的小伙伴。最早是我发现天奇在写 xgboost 的分布式启动脚本，我看了看发现挺好用，就跟他聊了聊。聊下的发现有很多基础部件例如启动脚本，文件读取应该是可以多个项目共同使用，而不是每个项目都造一个轮子。于是跟天奇在 Github 上创建了一个叫 DMLC 的组织，用来加强合作和沟通。第一个项目是 dmlc-core，放置了启动和数据读取代码。 </p><p>DMLC 的第二个新项目叫 wormhole。想法是提供一系列分布式机器学习算法，他们使用差不多相同的配置参数来统一用户体验。我把 parameter server 里面的机器学习相关算法移植了过来，天奇移植了 xgboost。Parameter server 原有的系统代码简化到了 ps-lite。 </p><p>中途我听百度同学说 factorization machine（FM）在广告数据上效果不错，所以在 wormhole 上实现了下。针对分布式做了一些优化，然后投了 WSDM。前后没有花到一个月，但神奇的竟然拿了最佳论文提名。</p><p>在 wormhole 的开发中发现一个问题，就是各个算法还是挺不一样，他们可以共用一些代码，但又有各自的特点，需要特别的优化来保证性能。这样导致维护有些困难，例如对共用代码的改动导致所有项目都要检查下。总结下来觉得一个项目最好只做一件事情。所以天奇把 xgboost 代码放回原来项目，我也把 FM 独立出来一个项目叫 difacto。</p><p>通过一系列的项目，我学到的一点是，以目前的水平和人力，做一个通用而且高效的分布式机器学习框架是很难的一件事情。比较可行的是针对一类相似的机器学习算法做针对性的项目。这个项目的接口必须是符合这类算法结构，所以做算法开发的同学也能容易理解，而不是过多暴露底层系统细节。</p><p>真正的让 DMLC 社区壮大的项目是第三个，叫做 MXNet。当时的背景是 CXXNet 达到了一定的成熟度，但它的灵活性有局限性。用户只能通过一个配置项来定义模型，而不是交互式的编程。另外一个项目是 zz 和敏捷他们做的 Minerva，是一个类似 numpy 的交互式编程接口，但这个灵活的接口对稳定性和性能优化带来很多挑战。我当时候同时给两个项目做分布式的扩展，所有都有一定的了解。然后一个自然的想法是，把两个项目合并起来取长补短岂不是很好。</p><p>召集了两个项目的开发人员讨论了几次，有了大致的眉目。新项目取名 MXNet，可以叫做 mixed-net，是前面两个名字（Minerva 和 CXXNet）的组合。放弃开发了几年的项目不是容易的决定，但幸运的是小伙伴都愿意最求更好，所以 MXNet 进展挺顺利。很快就有了可以跑的第一个版本。 </p><h3 id="第四年：9-15-8-16"><a href="# 第四年：9-15-8-16" class="headerlink" title="第四年：9/15-8/16"></a>第四年：9/15-8/16</h3><p>前半年为 difacto 和 MXNet 写了很多代码。其实一开始的时候我觉得 difacto 更重要些，毕竟它对于线性算法的提升非常显著而且额外的计算开销并不大，这对广告预估之类的应用会有非常大的提升。但有次遇到 Andrew Ng，我跟他说我同时在做这两个项目，他立即告诉我我应该全部精力放在 MXNet 上，这个的未来空间会大很多。我一直很佩服 Andrew 的眼光，所以听了他的建议。</p><p>11 月的时候 MXNet 就有了很高的完成度。写了个小论文投去了 NIPS 的 workshop 也算是歇了口气。但随后就听到了 TensorFlow（TF）开源的消息。由 Jeff Dean 领导大量全职工程师开发，Google 庞大的宣传机器支持，不出意料迅速成为最流行的深度学习平台。TF 对我们压力还是蛮大，我们有核心开发者转去用了 TF。不过 TF 的存在让我领悟到一点，与其过分关心和担忧对手，不如把精力集中在把自己的做得更好。</p><p>NIPS 的时候 MXNet 的小伙伴聚了一次，有好几个我其实是第一次见面。随后 Nvidia 的 GTC 邀请我们去做报告。在这两次之间大家爆发了一把，做了很多地方的改进。同时用户也在稳步增长。我们一直觉得 MXNet 是小开发团队所以做新东西快这是一个优势，但随着用户增加，收到抱怨说开发太快导致很多模块兼容性有问题。有段时间也在反思要在新技术开发速度和稳定性之间做一些权衡。</p><p>这时一夜之间大数据不再流行，大家都在谈深度学习了。</p><p>我也花了很多力气在宣传 MXNet 和争取开发者上。包括微博知乎上吼一吼，四处给报告。在大量的点赞声中有些陶醉，但很多中肯的批评也让我意识到重要的一点，就是应该真诚的分享而不是简单的吹嘘。</p><p>因为大量的媒体介入，整个深度学习有娱乐化的趋势。娱乐化的报道很多都只是一些简单信息，（有偏见）的观点，而没有太多干货。不仅对别人没营养，对自己来说也就是满足虚荣心。与其写这些简单的水文，不如静下心做一些有深度的分享，包括技术细节，设计思路，和其中的体会。</p><p>此类分享一个容易陷入的误区是只关注自己做了什么，结果多么好。这些确实能证明个人能力，对于想重复这个工作的人来说会有很大帮助。但更多的人更关心的是适用范围在哪里，就是什么情况下效果会减弱；为什么结果会那么好；insight 是什么。这个需要更多深入的理解和思考，而不是简单的展示结果。</p><p>这个对写论文也是如此。只说自己的结果比基线好多少只能说明这是不错的工作，但结果再好并不能意味这个工作有深度。</p><p>深度学习的火热导致了各种巨资收购初创司不断。Alex 也有点按耐不住， 结果是他，Dave，Ash（曾经是 YahooCTO）和我合伙弄了一家公司，拿了几十万的天使投资就开工了。Alex 写爬虫，Dave 写框架，我跑模型，风风火火干了好一阵子。可惜中途 Dave 跑路去跟 Jeff 做 TF 了。后来这个公司卖给了一个小上市公司。再后来我们觉得这个公司不靠谱也就没考虑跟他们干了。</p><p>第一次创业不能说很成功，从中学到几点：一是跟教授开公司一定要注意有太多想法但没死死的掐住一个做，二是找一堆兼职的博士生来干活不是特别靠谱，尤其是产品不明确的时候，三是即使要卖公司也一定要做一个产品出来。我们卖的时候给很多人的感觉是团队人太强但产品太弱，所以他们只想要人而已。四是试图想要通过技术去改变一个非技术公司是很难的事情，尤其是过于新的技术。</p><p>然后我们就奔去折腾下一个公司。Ash 早财务自由所以想做一个大的想法，但这时 Alex 刚在湾区买了个房，有还贷压力，他选择去了 Amazon。于是算是胎死腹中。</p><p>随后收到 Jeff 的邮件说有没有兴趣加入 Google，自然这是一个很诱人的机会。同时我觉得小的创业技术性强的公司是不错的选择。但从 MXNet 的发展上来书，去 Amazon 是最好选择之一。自己挖的坑，总是要自己填的。所以我以兼职的身份去了 Amazon，领着一帮小弟做些 MXNet 开发和 AWS 上深度学习的应用。</p><h3 id="第五年：9-16-2-17"><a href="# 第五年：9-16-2-17" class="headerlink" title="第五年：9/16-2/17"></a>第五年：9/16-2/17</h3><p>早在 15 年初 Alex 就表示我可以毕业了，但作为拖延晚期患者，迟迟没开始准备。这时候感觉不能再拖了，于是窝在湾区写毕业论文。Alex 觉得毕业论文应该好好写，但我对把前面都做完的东西再捣鼓写写实在是没兴趣，尤其是加州太阳那么好，大部分时间我都是躺在后院晒太阳。此时 B 站已经完全被小学生占领，这边买书也不方便，无聊之余刷了很多起点。然后还写了篇炼丹文。 </p><p>CMU 要求答辩委员会需要有三个 CMU 老师和一个学校外的。除了两个导师外，我找了 Jeff Dean 和刚加入 CMU 的 Ruslan Salakhutdinov. 结果 Russ 随后就加入了 Apple，整个委员会的人都在湾区了。Jeff 开玩笑说可以来 Google 答辩。可惜跟 CMU 争吵了好多次，还是不允许在校外答辩，而且必须要三个人委员会成员在场。这些限制导致答辩一拖再拖，而且临时加了 Barnabas Poczos 来凑人数。最后是 Jeff 的助理快刀斩乱麻的协调好了时间把所有东西定好了。没有她估计我还可以拖几个月。</p><p>答辩的时候是一个比较奇异的状态，委员会里有 Google, Amazon, Apple 的 AI 负责人，剩下两个和我又分别在这三家公司兼职。这个反应了当下 AI 领域学术界纷纷跑去工业界的趋势。 </p><p>不过答辩这个事情倒是挺简单，跟平常做个报告没什么太多区别。一片祥和，即使 Russ 问了 MXNet 和 TensorFlow 哪家强这个问题也没有打起来。</p><p>答辩后我问委员会说，我在考虑找个学术界的工作，有什么建议没。大家介绍了一大堆经验，不过大家都强调的一个重点是：学术界好忙好忙，而且好穷好穷，工业界的薪水（就差指自己脸了）分分钟秒掉 CMU 校长。你要好好想。</p><h3 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h3><p> 答辩前一天的晚上，我想了两个问题，一个是“博士收获最大的是什么”，另一个是“如果可以重来会怎么办”。对于第一个问题，这五年时间自然学到了很多东西，例如系统的学习了分布式系统，紧跟了机器学习这五年的发展，写文章做幻灯片做报告水平有提升，代码能力也加强了些。自信上有所提高，觉得既可以做一流的研究，也可以写跟大团队 PK 的代码。只要努力，对手没什么可怕的。</p><p>但更重要的是博士的五年的时间可以专注的把一些事情从技术上做到最好，做出新的突破，这个氛围没有其他地方能给予。</p><p>第二个问题的一个选项是当年留在国内会怎么样？ 当年百度的伙伴们多数现在都做得很好，都在引领这一波 AI 的潮流，甚至有好几个创造了上亿价值的公司。所以从金钱或者影响力角度来看，一直在工业界也不差，说不定现在已经是土豪了。</p><p>不过我觉得还是会选择读博。赚钱以后还有大把时间可以，但是能花几年时间在某个领域从入门到精通甚至到推动这个领域发展的机会就一次。站在这个领域的高点会发现世界虽然很大，但其实其他领域也使用差不多的技术，有着同样的发展规律。博士期间领悟到的学习的方法可以在各个方向上都会大有作为。</p><p>更重要的是理想和情怀。人一生要工作五十年，为什么不花五年来追求下理想和情怀呢？</p><hr><h3 id="读后感："><a href="# 读后感：" class="headerlink" title="读后感："></a>读后感：</h3><p>以前听人说，把知识比作一个圆，圈内的就是人类已知的知识，那么圈外无穷无尽的则是未知之境。又听人说过，本科毕业要求会用别人的方法重复解决别人的问题，硕士毕业要求会用别人的方法解决自己的研究问题，而博士毕业要求会创造方法解决自己的研究问题。博士（生）正是这种倾力拓展人类知识边界的知识耕耘者。根据自己的见闻，那些即将毕业的、声称绝不读博的硕士研究生，许多最后要么直接读博，要么工作一两年后再读博，那些下定决心读博的硕士更不必说了，也读博了，但是真正想清楚读博意义的人恐怕不多。（我看到的）许多博士生读博的原因有真心热爱科研、改变专业或者出身、硕导推荐或者建议、一不小心（随波逐流）、为学位等等。最酷的事情就是真正热爱科研、花几年时间在某个领域从入门到精通甚至到推动这个领域发展。关于为什么读博，我觉得 <a href="http://bitjoy.net/2018/02/14/why-phd/" target="_blank" rel="noopener"> 一念成博 </a> 里的一句话说得很好：“在一个很安全的环境里，父母健在，自己不用操心赚钱养家；有老板给你提供指导、资金；你可以安心研究自己感兴趣的问题；发表的文章也将署上自己的名字，流传后世；习得的技能也将转化为自己的能力；获得的博士学位也将是自己的荣誉…”。Fighting, 博士生！</p><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/25099638" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25099638</a><br><a href="http://www.cs.cmu.edu/~muli/" target="_blank" rel="noopener">李沐介绍</a></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas dataframe 更改列名</title>
      <link href="/2019/09/29/pandas-change-columns2/"/>
      <url>/2019/09/29/pandas-change-columns2/</url>
      
        <content type="html"><![CDATA[<p> 摘要：在生物信息学数据分析中，经常需要整合多个文档的数据，其中经常会遇到需要依据某个文件中的信息更改另外一个相关文件列名的问题，本文给出了一种更改方法。<br><a id="more"></a><br> 假设文件 A 包含信息如下：</p><div class="table-container"><table><thead><tr><th>chipID</th><th>drugID</th></tr></thead><tbody><tr><td>CVD001_HUH7_24H:BRD-A19037878:10</td><td>trichostatin-a</td></tr><tr><td>CVD001_HUH7_24H:BRD-A19500257:10</td><td>geldanamycin</td></tr><tr><td>CVD001_HUH7_24H:BRD-A29349577-001-04-0:2.5</td><td>dropropizine</td></tr><tr><td>CVD001_HUH7_24H:BRD-A36411721-001-01-0:14.3</td><td>BRD-A36411721</td></tr><tr><td>CVD001_HUH7_24H:BRD-A37828317-001-03-0:2.5</td><td>anthothecol</td></tr><tr><td>CVD001_HUH7_24H:BRD-A41649729-001-01-0:10</td><td>BRD-A41649729</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div><p> 文件 B 的标头是 chipID，如果想要把 B 的表头改为 A 中 chipID 对应的 drugID, 那么方法可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">A_content = pd.read_table(A_filename,sep=&quot;\t&quot;)</span><br><span class="line"># 构造 chipID 为键，drugID 为值的字典 </span><br><span class="line">new_dict = dict(zip(A_content.chipID,A_content.drugID))</span><br><span class="line"># 读取 B 文件 </span><br><span class="line">B_content = pd.read_table(B_filename,sep=&quot;\t&quot;)</span><br><span class="line"># 更改 B 的列名 </span><br><span class="line">B_content.rename(columns=new_dict,inplace=True)</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h2>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物网络的概念（二）：无标度网络（scale-free network)</title>
      <link href="/2019/09/22/labelFreeNetwork/"/>
      <url>/2019/09/22/labelFreeNetwork/</url>
      
        <content type="html"><![CDATA[<p>摘要：无标度网络（scale-free network）是一种重要的网络类型，因其能够很好地体现许多社会学、互联网以及生物学中的相互作用关系而受到了广泛的关注。本文将对无标度网络以及相关的概念进行初步的介绍。<br><a id="more"></a></p><h3 id="无标度网络的概念及其意义"><a href="# 无标度网络的概念及其意义" class="headerlink" title="无标度网络的概念及其意义"></a>无标度网络的概念及其意义 </h3><p> 无标度网络是一种所有节点（node）的度（degree）服从幂分布 (Power law distribution) 的网络 [1]。<br> 研究人员发现在很多网络中，少量的节点拥有整个网络的大部分连接度，而多数节点的连接度却非常小，这个现象符合幂分布的特点，并称这样的网络为无标度网络。如下图所示：</p><p><img src="/2019/09/22/labelFreeNetwork/network.PNG" alt></p><p>要想理解什么是无标度网络（scale-free network)首先要了解什么是幂分布。幂分布的定义是当样本数据较多时，变量 x 的概率密度函数：f(x)~x^(-α-1)。</p><p>不像正态分布那样个体的尺度在某个值附近变化很小，比如说人的身高、体重、智商，幂分布个体的尺度可以在很宽的范围内变化，这种波动往往可以跨越几个甚至几十个数量级。由此我们可以想到 20/80 法则、马太效应、“天之道，损有余而补不足；人之道则不然，损不足以奉有余”等等等等。幂分布充分地体现了重要的少数与琐碎的多数的关系，因此在社会学乃至生物学研究中都受到了广泛关注。</p><h3 id="构建无标度网络的方法步骤以及代码实现"><a href="# 构建无标度网络的方法步骤以及代码实现" class="headerlink" title="构建无标度网络的方法步骤以及代码实现"></a>构建无标度网络的方法步骤以及代码实现</h3><p>WGCNA（weighted gene co-expression netwrk analysis）是一种重要的构建共表达网络的方法，也是对应 R 包的名字。该方法就是基于输入的基因表达值（基因芯片或者 RNA-seq 数据），构建基于无标度网络的基因共表达网络，然后去分析基因之间的相似性、将具有相似功能的基因聚类成同一模块、将模块与不同性状联系起来以及鉴定模块内的驱动基因（driver gene）等等。使用 R 包 WGCNA 构建无标度网络的重要步骤是：</p><h4 id="（一）选取合适的 power 值（β）使得网络接近 scale-free 网络，选取β的代码及步骤如下（假定在 R 软件里已经安装好 WGCNA）："><a href="#（一）选取合适的 power 值（β）使得网络接近 scale-free 网络，选取β的代码及步骤如下（假定在 R 软件里已经安装好 WGCNA）：" class="headerlink" title="（一）选取合适的 power 值（β）使得网络接近 scale-free 网络，选取β的代码及步骤如下（假定在 R 软件里已经安装好 WGCNA）："></a>（一）选取合适的 power 值（β）使得网络接近 scale-free 网络，选取β的代码及步骤如下（假定在 R 软件里已经安装好 WGCNA）：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">## 导入 WGCNA 包</span><br><span class="line">library(&quot;WGCNA&quot;)</span><br><span class="line"></span><br><span class="line">## 构建幂的向量，一般构建 unsigned 网络，幂 power&lt;15；signed 网络幂 power&lt;30，这里以 unsigned 为例</span><br><span class="line">powers1=seq(from=1,to=15,by=1)</span><br><span class="line"></span><br><span class="line">## 导入包含样品基因表达量的文件，该文件第一列为基因名，列名为样品名称</span><br><span class="line">datExprdataOne1 = read.table(filepath,header = T,sep=&quot;\t&quot;)</span><br><span class="line"></span><br><span class="line">## 把重复的基因名字合并，使用平均值的方法；如果没有重复基因名该步骤也可以不做</span><br><span class="line">datExprdataOne2 = aggregate(datExprdataOne1[,2:dim(datExprdataOne1)[2]],by=list(datExprdataOne1[,1]),FUN=mean)</span><br><span class="line"></span><br><span class="line">## 把基因名字作为合并重复值后数据框的行名</span><br><span class="line">row.names(datExprdataOne2) &lt;- datExprdataOne2$Group.1</span><br><span class="line"></span><br><span class="line">## 删除 datExprdataOne2 的 Group.1 列</span><br><span class="line">datExprdataOne3 &lt;- datExprdataOne2[,2:dim(datExprdataOne2)[2]]</span><br><span class="line"></span><br><span class="line">## 将数据框转置，即列名为样品名称，行名为基因名称</span><br><span class="line">datExprdataOne = t(datExprdataOne3)</span><br><span class="line"></span><br><span class="line">## 遍历每一个 powers1 向量中的 power，寻找最优的 power</span><br><span class="line">pst=pickSoftThreshold(datExprdataOne,powerVector=powers1,moreNetworkConcepts=T)[[2]]</span><br><span class="line"></span><br><span class="line">## 遍历每一个 powers1 向量中的 power，将以该 power 为幂的网络相关指标展现出来</span><br><span class="line"></span><br><span class="line">tiff(PictureName,width=800,heiht=480,units=&quot;px&quot;,pointsize=10)</span><br><span class="line"></span><br><span class="line">cex1=1.2;cex.axis=1.5;cex.lab=1.5;cex.main=1.5</span><br><span class="line"></span><br><span class="line">par(mfrow=c(2,2),mar=c(4,4,3,2)+0.1)</span><br><span class="line"></span><br><span class="line">plot(powers1,-sign(pst[,3])*pst[,2],type=&quot;n&quot;,</span><br><span class="line">     xlab=&quot;Soft Threshold&quot;,</span><br><span class="line">     ylab=&quot;SFT,signed Rˆ2&quot;,cex.axis=cex.axis,cex.main=cex.main,</span><br><span class="line">     cex.lab=cex.lab,main=&quot;Scale Free Fit Index Rˆ2&quot;)</span><br><span class="line"></span><br><span class="line">text(powers1,-sign(pst[,3])*pst[,2],</span><br><span class="line">     labels=powers1,cex=cex1,col=&quot;red&quot;)</span><br><span class="line"></span><br><span class="line">plot(powers1,pst$Density,</span><br><span class="line">     type=&quot;n&quot;,xlab=&quot;Soft Threshold&quot;,ylab=&quot;Density&quot;,</span><br><span class="line">     cex.axis=cex.axis,cex.main=cex.main,cex.lab=cex.lab,</span><br><span class="line">     main=&quot;Density&quot;)</span><br><span class="line"></span><br><span class="line">text(powers1,pst$Density,labels=powers1,cex=cex1,col=&quot;red&quot;)</span><br><span class="line"></span><br><span class="line">plot(powers1,pst$Heterogeneity,type=&quot;n&quot;,xlab=&quot;Soft Threshold&quot;,</span><br><span class="line">     ylab=&quot;Heterogeneity&quot;,cex.main=cex.main,cex.lab=cex.lab,</span><br><span class="line">     cex.axis=cex.axis,main=&quot;Heterogeneity&quot;)</span><br><span class="line"></span><br><span class="line">text(powers1,pst$Heterogeneity,labels=powers1,cex=cex1,col=&quot;red&quot;)</span><br><span class="line"></span><br><span class="line">plot(powers1,pst$Centralization,type=&quot;n&quot;,xlab=&quot;Soft Threshold&quot;,</span><br><span class="line">     ylab=&quot;Centralization&quot;,cex.axis=cex.axis,cex.main=cex.main,</span><br><span class="line">     cex.lab=cex.lab,main=&quot;Centralization&quot;)</span><br><span class="line"></span><br><span class="line">text(powers1,pst$Centralization,labels=powers1,cex=cex1,col=&quot;red&quot;)</span><br><span class="line"></span><br><span class="line">dev.off()</span><br></pre></td></tr></table></figure><p>最终得到的图片形式类似下图所示：</p><p><img src="/2019/09/22/labelFreeNetwork/Cortex_expression_data_in_GTEx.txtdrop_median_0..png" alt></p><p>结果解释：<br>左上图：x 轴表示不同的 power 值；y 轴表示 scale-free topology index R2，该值越大表明其所对应的网络越接近 scale-free 网络。 一般情况下 power 的值越大，R2 越大。</p><p>右上图：x 轴表示不同的 power 值；y 轴表示网络的 Density，含义接近于网络的平均 connectivity，越大表示网络节点间相互联系越紧密，反之则不紧密，接近 scale-free 网络。一般情况下 power 值越大 Density 越小，网络越接近 scale-free 网络。</p><p>左下图：x 轴表示不同的 power 值；y 轴表示 Heterogeneity，用以衡量网络节点间 connectivity 的变异程度。</p><p>右下图：x 轴表示不同的 power 值；y 轴表示 Centralization，越接近 1 表明网络具有星形拓扑结构，越接近 0 表明网络每个节点具有相同的连接度。一般 power 值越小，Centralization 越大，网络越接近 scale-free 网络。</p><p>综上所述，考虑到上述四种指标，一般情况下 power 值的选择要看使 R2 超过 0.8 的最小 power 值。如果实在没有符合要求的 power，可选取经验值，即 unsigned 网络 power=6;signed 网络 power=12。</p><h4 id="（二）基于β值构建网络模块"><a href="#（二）基于β值构建网络模块" class="headerlink" title="（二）基于β值构建网络模块"></a>（二）基于β值构建网络模块 </h4><p> 使用上一步得到的 datExprdataOne 和β，构建基因共表达网络。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NetWork = blockwiseModules(datExprdataOne, power = β, maxBlockSize = nGenes,</span><br><span class="line">                       TOMType = type, minModuleSize = 30,</span><br><span class="line">                       reassignThreshold = 0, mergeCutHeight = 0.25,</span><br><span class="line">                       numericLabels = TRUE, pamRespectsDendro = FALSE,</span><br><span class="line">                       verbose = 3)</span><br></pre></td></tr></table></figure></p><p>重要参数解释：<br>power：经过第一步分析得到的最优 power 值；  </p><p>maxBlockSize: 一般情况下构建网络的时候会把输入的表达矩阵分成几份（block）分别计算。如果计算资源充足，最好不拆分矩阵。做法是 MaxBlockSize≥矩阵包含的基因数目；</p><p>TOMType: 值可以为”none”, “unsigned”, “signed”, “signed Nowick”, “unsigned 2”, “signed 2” and “signed Nowick 2”；  </p><p>numericaLabels: 逻辑值（F/T），F 则表示得到的模块用颜色标记，T 则表示得到的模块用数字标记。</p><p>后续下游分析可参考<a href="http://blog.sciencenet.cn/blog-118204-1111379.html" target="_blank" rel="noopener">WGCNA 分析，简单全面的最新教程</a>。</p><p>参考资料：<br>[1] Cesar A. Hidalgo and Albert-Laszlo Barabasi (2008), Scholarpedia, 3(1):1716.<br>[2] Langfelder, Peter, and Steve Horvath. “WGCNA: an R package for weighted correlation network analysis.” BMC bioinformatics 9.1 (2008): 559.</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生物网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>药物基因组学数据库 Connectivity Map 使用方法简介（二）</title>
      <link href="/2019/09/14/Cmap_tools/"/>
      <url>/2019/09/14/Cmap_tools/</url>
      
        <content type="html"><![CDATA[<p>摘要：Connectivity Map(CMap)是 2006 年推出的数据库，之后经过一次更新，使得数据库包含了 1309 个小分子药物处理五类人类肿瘤细胞系后的约 7000 个基因表达谱数据。数据库历经十几年，仍然是研究药物基因组学的科研人员不可或缺的宝贵资源。CMap 数据库提供了的网页分析工具，本文将简要介绍一下其使用方法。<br><a id="more"></a></p><h3 id="数据准备"><a href="# 数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>1）用户需提供基于 Affy Metrix HG-U133A 或者 HT_HG-U133A_EA 或者 HT_HG-U133A 平台的基因芯片数据。因为 CMap 的 7000 多个基因芯片数据是基于上述平台的，其中 5000 多个是基于 HT_HG-U133A 平台的，所以基于模式匹配算法的网页工具也需要用户提供一致的数据类型。Affy Metrix 官网提供了将基因与探针集相互转化的信息和工具。</p><p>2）根据研究目的，提供相应的上下调探针集列表。例如，如果研究某种疾病，那么就要提供疾病组 vs 正常组的上调和下调探针集列表；如果要研究药物的作用，那么就要提供处理组 vs 对照组的上调和下调探针集列表（注：网站限制上下调探针集总数在 1000 以内）。<br>3）将上下调基因列表文件转化为.grp 格式。就是将上下调基因列表文件后缀名改为.grp。如下图所示:</p><p><img src="/2019/09/14/Cmap_tools/grp.PNG" alt></p><h3 id="数据处理"><a href="# 数据处理" class="headerlink" title="数据处理"></a>数据处理 </h3><p> 数据输入接口有四种，即</p><p><img src="/2019/09/14/Cmap_tools/query_page.PNG" alt></p><p>点击“浏览”，分别上传本地存放的上下调探针集列表文件。然后点击”execute query”执行分析，等待，点击“view results now”就可以看到分析结果。</p><p><img src="/2019/09/14/Cmap_tools/load_signature.PNG" alt></p><p>load signature 与 quick query 的区别就是：load signature 可以让用户对每一次的分析做个性化描述，这对同时执行多次不同分析的用户来说很有用，而 quick query 则简单粗暴，适合一次性分析，不提供数据描述和命名功能。</p><p><img src="/2019/09/14/Cmap_tools/signature_query.PNG" alt></p><p>用户想再重新分析一下以前上传的上下调探针集列表，可以使用 signature query。只要找到以前分析结果的名字即可直接用于新的分析。还有一种是选择数据库中自带的 instance 作为输入，研究该 instance 与 CMap 其他 instances 的联系，这种方法操作起来和上面差不多，在此不再赘述。</p><h3 id="结果解释"><a href="# 结果解释" class="headerlink" title="结果解释"></a>结果解释 </h3><p> 用户提交数据进行分析之后会得到分析结果，结果展示了基于 CMap 的模式匹配算法，用户提供的表达谱与 CMap 各个药物处理产生的表达谱相似或者相异程度。结果有两种展现方式。如下图所示：  </p><p><img src="/2019/09/14/Cmap_tools/cmap_result.PNG" alt><br>用户根据自己研究目的不同来选择不同的分析结果。一种是 detailed results(基于 connnectivity score 的展示方式)，该法是以单个 instance 为中心，也就是展示 CMap 数据库中每一个 instance 与用户提交探针集的关系（结果解释参见 <a href="http://eatdrinkbreathe.top/2019/09/01/ 药物基因组学数据库 Connectivity map 简介 /"> 药物基因组学数据库 Connectivity Map 使用方法简介（一）</a>）；另一种是 permuted results(基于 instance 集合的结果展示方式)，instance 集合的种类有三类，即同一种药物处理得到的 instance 集合（<strong>by name</strong>，不论什么浓度、处理什么细胞系、处理多长时间），同一药物处理同一细胞系的 instance 集合（<strong>by name and cell line</strong>，不论什么浓度、什么处理时长），同属于一个 ATC code 的药物处理得到的 instance 集合（<strong>by ATC code</strong>）。然后分别计算每个 instance 集合的 Enrichment score 和 p value，最终基于 p value 和 Enrichment score 对每个 instance 集合排序。结果如下图所示：</p><p><img src="/2019/09/14/Cmap_tools/enrichment_result.PNG" alt><br>第一列 <strong>rank</strong> 是每个 instance 集合的排名（基于 p value 升序排序，基于 enrichment 的绝对值降序排序）；</p><p>第二列是 instance 集合（by name，by name and cell line，by ATC code）的名称； </p><p>第三列 <strong>mean</strong> 是每个 instance 集合对用户探针集的 connectivity score 的平均值；  </p><p>第四列 <strong>n</strong> 是每个 instance 集合的大小；</p><p>第五列 <strong>erichment</strong> 是每个 instance 集合包含的 instance 的排名与所有 instance（7000 多个）排名的 KS 检验统计量，与 connectivity score 的区别是这里只有一个列表（即 instance 集合包含的 instance 排名），score = a 或者 -b；而计算 connectivity score 时 score = KSTop – KSBottom，要计算两次</p><p>第六列是计算每个 enrichment score 时的显著性 <strong>p</strong> 值。简单来说就是每次从所有 instance 中抽随机 n（每个 instance 集合的大小）个 instance，计算 enrichment score，重复操作十万次，计算出现绝对值大于 enrichment score 的次数 m，p=m/100000； </p><p>第七列 <strong>specificty</strong> 是指 312 个实验验证的上下调基因列表对每个 instance 集合的特异性。这 312 个具有明确生物学功能意义的列表可用于反映 instance 集合的功能特性；  </p><p>第八列 <strong>non-null</strong>是指 instance 集合中 connectivity score 不为零的 instance 所占百分比。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Connectivity Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>药物基因组学数据库 Connectivity Map 算法浅析</title>
      <link href="/2019/09/11/Cmap_algrith/"/>
      <url>/2019/09/11/Cmap_algrith/</url>
      
        <content type="html"><![CDATA[<p>摘要：Connectivity Map 是药物基因组学研究领域的一个宝库，近些年来有许多计算生物学家开始对这个重要数据库进行挖掘，进行了包括但不限于组合药物研究、药物重定位研究等等，也有许多计算生物学家对 connectivity map 网站提供的联结“药物 - 基因 - 疾病”的算法提出了改进。他山之石可以攻玉，本文将尝试对 connectivity map 所使用的 Kolmogorov–Smirnov test 进行初步的解读。</p><a id="more"></a><h3 id="拟合优度检验"><a href="# 拟合优度检验" class="headerlink" title="拟合优度检验"></a>拟合优度检验 </h3><p> 统计学学习中我们经常会遇到需要判断两组观测数据是否具有一致性的问题，解决办法之一就是拟合优度检验（Goodness of fit test）。拟合优度检验是基于卡方统计量进行统计的一种显著性检验，除了可以用来判断两组数据是否具有一致性外，也可以用来判断观测数据是否符合某种统计学分布。常见的拟合优度检验方法有：Neyman-Pearson χ2 拟合优度检验、Kolmogorov-Smirnov 检验等等。</p><h3 id="经验分布函数"><a href="# 经验分布函数" class="headerlink" title="经验分布函数"></a>经验分布函数 </h3><p> 设 x1,x2,…,xn 是总体 X 的一组容量为 n 的样本测量值，将它们按照从小到大的顺序重新排列为 x1∗,x2∗,⋯,xn∗，对于任意实数 x，定义函数 </p><script type="math/tex; mode=display">F_n(x)=\begin{cases}0,\quad x<x^*_1\\k/n,\quad x^*_{k}\leq x<x^*_{k+1}, \quad k=1,2,\cdots,n-1\\1,\quad x^*_n\leq x\end{cases}</script><p>则称 Fn(x)为总体 X 的经验分布函数。它还可以简记为 Fn(x)=1/n⋅ ∗{x1,x2,⋯,xn}，其中∗{x1,x2,⋯,xn}表示 x1,x2,⋯,xn 中不大于 x 的个数。<br>另外一种常见的表示形式为 </p><center> $F_n(x)=\frac{1}{n}\sum_{i=1}^nI\{x_i\leq x\}$ </center><p>其中，I 是 indicator function, 即 </p><center> $I\{x_i\leq x\}=\begin{cases}1,\quad x_i\leq x\\0,\quad otherwise\end{cases}$ </center><p>因此，求经验分布函数 Fn(x) 在一点 x 处的值，只要求出随机变量 X 的 n 个观测值 x1,x2,⋯,xnx 中小于或等于 x 的个数，再除以观测次数 n 即可。由此可见，Fn(x) 就是在 n 次重复独立实验中事件 {X≤x}出现的频率。</p><h3 id="KS 统计的基础知识"><a href="#KS 统计的基础知识" class="headerlink" title="KS 统计的基础知识"></a>KS 统计的基础知识</h3><p>K-S 检验全称是 Kolmogorov–Smirnov test，是一种非参数检验（参数检验与非参数检验的区别，简单来说就是：参数检验是检验平均数、方差等参数做的假设，而非参数检验则是对总体分布情况做的假设），基于累积分布函数，通过对两个分布之间的差异分析，判断两样本是否来自同一个总体或者判断某个样本分布是否服从特定分布。由于对分布函数的位置和形状参数的差异都敏感，K-S 检验成为比较两样本最有用且常规的非参数检验方法之一。</p><p>对于两个独立随机样本 X={X1,X2,X3,…,Xm}和 Y={Y1,Y2,Y3,…,Yn}, 设其经验分布函数分别为 F，G。如果想检验 X 和 Y 之间是否存在差异，首先<br>(1）提出假设 H0：Fn(x)=Gn(y)，那么可以建立以下假设：<br>H0：F(t) = G(t),  for every t<br>H1：F(t) ≠ G(t),  for at least one t</p><center> $F_n(x)=\frac{1}{m}\sum_{i=1}^mI\{x_i\leq x\}$ </center><center> $G_n(y)=\frac{1}{n}\sum_{i=1}^nI\{y_i\leq y\}$ </center><p>(2)  假设建立以后就要计算检验统计量了。K-S 检验的统计量定义是：样本累计频率与理论分布累计概率的绝对差，令最大的绝对差为 Dn，Dn=max{[Fn(x) - F(x)]};<br>(3) 用样本容量 n 和显著水平 a 查出临界值 Dna；<br>(4) 如果 Dn&lt; Dna，则认为拟合是满意的。</p><h3 id="connectivity-score 背后的假设及意义"><a href="#connectivity-score 背后的假设及意义" class="headerlink" title="connectivity score 背后的假设及意义"></a>connectivity score 背后的假设及意义 </h3><p> 如果某疾病引起的上调基因列表表达量的统计分布与某药物引起的下调基因列表表达量分布一致，同时 / 或者该疾病引起的下调基因列表表达量的统计分布与该药物引起的上调基因列表表达量分布一致，那么就可能说明疾病影响的基因与药物影响的基因属于同一分布，来自同一总体，而作用方向相反，正负得零，那么该药物就可能使疾病状态恢复到正常。</p><h3 id="connectivity-score 的计算方法"><a href="#connectivity-score 的计算方法" class="headerlink" title="connectivity score 的计算方法"></a>connectivity score 的计算方法 </h3><p> 由于 KS 检验是一种非参数方法，不依赖均值的位置，适用范围广，对于基因表达量的统计分布来说是比较稳妥的统计检验方法。因此 CMAP 算法采用基于排序的 Kolmogorov-Smirnov (KS)统计方法，将疾病基因表达谱与药物表达谱联系起来。KS 统计量（up score 和 down score）是根据疾病基因表达谱 (即 top 和 down 列表) 在药物表达谱中的排名计算得到的。<br>具体做法是：<br>(1) 将基因按照药物处理细胞系后产生变化的大小降序排列，即药物上调的倍数越大排名越靠前，rank=1, 2, …, 22283；<br>(2)将疾病基因列表与药物表达谱基因列表取交集，得到一个新的基因列表 CommonGenes；<br>(3) 得到 CommonGenes 在降序排序后药物表达谱的排名，然后将排名升序排列，假设向量大小为 t，则 j= 1, 2, …, t。构建经验分布函数，对于 CommonGenes 来说，其经验分布函数是</p><center> $F_n(j)=\frac{j}{t}$ </center><p>(4) 得到 CommonGenes 在降序排序后药物表达谱的排名，然后将排名升序排列得到向量 V（j），假设向量大小为 t，则 j= 1, 2, …,t。构建经验分布函数，对于 CommonGenes 来说，其经验分布函数是</p><center> $G_n(j)=\frac{V(j)}{n}$ </center><p>(5) 所以 CMap 算法的 KS 统计量计算公式为：</p><p><img src="/2019/09/11/Cmap_algrith/image011.gif" alt></p><p><img src="/2019/09/11/Cmap_algrith/image013.gif" alt></p><p>其中 if  a &gt; b，KSTop/Bottom = a<br>　　 else       KSTop/Bottom = -b；<br>　　 if  KSTop * KSBottom &lt; 0<br>　　 score = KSTop – KSBottom<br>　　 else  score = 0</p><p>对于该算法的一些理解：<br>（1）由于 KS 检验的统计量就是两个经验分布的最大距离（差值），那么计算 a 了之后为什么还要计算 b？我们可以看到 b 几乎等于 -a，仅仅加上了一个 1/t，当 t 很大时 1/t 可以忽略不计。这是因为 a 计算的时候包含正负符号，并不是真正意义上的距离（绝对值）。例如假设 a=max{-3,-2,-1,0,1,2}, 那么 a=2，我们知道 2 并不是最大距离，因为还有一个 -3, 因此为了得到真正意义上的最大距离，需要计算 b。</p><p>（2） 为什么 a &gt;  b 则 KS=a;b&gt;a 则 ks=-b 呢？为什么要加上一个负号？是因为这种方法可以区分以下两种情况：<br>①疾病上调基因列表于药物上调基因列表一致（a1&gt;b1，ksup=a1，以及疾病下调基因列表于药物下调基因列表一致 (b2&gt;a2，ksdown=b2)；<br>②疾病上调基因列表于药物下调基因列表一致(a3&lt; b3, ksdown=b3)，以及疾病下调基因列表于药物上调基因列表一致（a4&gt;b4，ksup=a4)；<br> 若 a &gt;b 则 KS=a;b&gt;a 则 ks=b，不加负号，则①情况 score = KSTop – KSBottom=a1-b2；②score = KSTop – KSBottom=b3-a4。在此 (a1-b2) 正负号未知，（b3-a4)正负号也未知，也就无法区分①、②两种情况。如若将 a &gt;b 则 KS=a;b&gt;a 则 ks=-b，则在此 (a1+b2) 始终为正，（-b3-a4)始终为负，也就区分①、②两种情况。如此，本人佩服算法研究人员的缜密与创造性！</p><p>(3) 为什么计算 b 的时候是 (j-1) 而不是 j？<a href="https://www.cnblogs.com/datamining-bio/p/8684420.html" target="_blank" rel="noopener">dedication</a>博客给出了比较合理的解答：</p><blockquote><blockquote><p>我们再来看看计算 b 的公式，它将 i 减了 1，即将集合 B 中的基因位置向前推了一位，这是为什么呢？我们看下图 8 的情况。<br><img src="/2019/09/11/Cmap_algrith/1362527-20180331215135026-1073998294.png" alt><br>当基因 Q 刚好在疾病中位于第 N 个，在药物数据中位于第 M 个，也就是说，该基因在疾病状态下被抑制，表达量非常少，而在药物作用下产生促进表达作用，表达量增加很多，很明显，该药物对该疾病的治疗效果应该很好，称为该疾病的特效药的可能性也很高，如果我们在计算 b 的时候，不减 1，那么 b=0，后面的异号条件也不满足，那么我们就漏掉了很好的这种情况，为了避免，就将集合 B 的基因位置向前推一个。</p></blockquote></blockquote><h3 id="参考资料"><a href="# 参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/datamining-bio/p/8684420.html" target="_blank" rel="noopener">KS 检验统计量的扩展应用（CMap）</a></p><p><a href="https://blog.csdn.net/baimafujinji/article/details/51720090" target="_blank" rel="noopener">经验分布函数（Empirical Distribution Functions）</a></p><p><a href="https://blog.csdn.net/qq_41679006/article/details/80977113" target="_blank" rel="noopener">Kolmogorov–Smirnov test（K-S 检验）</a></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Connectivity Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>药物基因组学数据库 Connectivity Map 使用方法简介（一）</title>
      <link href="/2019/09/01/Cmap_tools1/"/>
      <url>/2019/09/01/Cmap_tools1/</url>
      
        <content type="html"><![CDATA[<p>摘要：Connectivity Map 是药物基因组学研究领域的重要数据库，是计算生物学和药物筛选研究人员做研究时不得不重视的数据库。它不仅提供大量宝贵的药物处理人类细胞系前后的基因表达谱数据，而且也提供了基于模式匹配算法的在线工具，用户提交合适的基因列表就能得到该数据库中与之相关的药物。<br><a id="more"></a></p><h3 id="Connectivity-map 的重要性及地位、发展历史及版本"><a href="#Connectivity-map 的重要性及地位、发展历史及版本" class="headerlink" title="Connectivity map 的重要性及地位、发展历史及版本"></a>Connectivity map 的重要性及地位、发展历史及版本 </h3><p> 做药物筛选试验的研究人员以及做计算生物学数据分析的研究人员，应该对美国博德研究所的 <a href="https://portals.broadinstitute.org/cmap/" target="_blank" rel="noopener">Connectivity Map</a>(CMap) 数据库都不陌生。CMap 是药物基因组学研究领域内非常重要的数据库，目前网页版数据库已更新至第二版。该数据库自 2006 年发布至 2019 年 9 月初已被引用超过 3000 次（数据来源于谷歌学术）。Cmap 旨在通过基因表达量的变化来发现药物、基因和疾病之间的功能联系。最近十年来在药物组合和药物重定位研究中扮演着越来越重要的角色。</p><h3 id="数据量及数据类型"><a href="# 数据量及数据类型" class="headerlink" title="数据量及数据类型"></a>数据量及数据类型</h3><p>CMap 数据库包含了 1309 种小分子药物处理 5 种人类肿瘤细胞系前后的基因芯片数据。处理条件多种多样，包括不同药物、不同浓度、不同处理时长等等，大多数处理条件都有三个处理样本以及对应的三个及以上空白对照组。</p><h3 id="CMap 的结果解释"><a href="#CMap 的结果解释" class="headerlink" title="CMap 的结果解释"></a>CMap 的结果解释 </h3><p> 做计算生物学的用户往往会把 CMap 所有的基因芯片数据下载下来然后做各自的后续分析，而对于普通湿实验用户，该数据库也提供了网页版分析工具，只要用户提供两个文档（分别包含上调基因和下调基因）就能够得到 CMap 中与用户提供基因列表相关（正相关和负相关）的药物列表，从而为用户进行药物分析提供指导。用户最感兴趣应该就是 barview 中红绿颜色代表的药物了，也就是 connectivity score 不为零的那些 instance 代表的药物。具体来说，用户按要求上传自己的基因列表后会得到数据库返回的结果，如下图所示:</p><p><img src="/2019/09/01/Cmap_tools1/cmap_result.PNG" alt></p><p>针对用户提供的两个基因列表:<br><strong>barview</strong>给出 CMap 所有 instance(一种药物在一种浓度下处理特定时长的一种细胞系，产生的数据就是一个 instance）与其关联度（connectivity score）的图形化展示。绿色代表正相关，红色代表负相关，灰色代表不相关。每个正值 connectivity score 代表正相关，背后的假设是药物扰动的表达谱与疾病扰动的表达谱正相关，可以简单地认为药物可以引起或者加剧该疾病状态；反之，每个负值 connectivity score 代表负相关，背后的假设是药物扰动的表达谱与疾病扰动的表达谱负相关，可以简单地认为药物能够减轻甚至逆转该疾病状态。  </p><p><strong>rank</strong>是所有 instance 放在一起后的 connectivity score 排名，connectivity score 越大排名越靠前。</p><p><strong>batch</strong>是 instance 产生的批次，7000 多个基因表达谱数据由多个不同批次产生。  </p><p><strong>dose</strong>药物处理细胞系时的浓度。</p><p><strong>cell line</strong>是药物处理的细胞系类型。</p><p><strong>score</strong>是指 connectivity score，由 up score 和 down score 计算后再经过标准化得到，是相对数值。</p><p><strong>up/down</strong>分别指用户上传的上调 / 下调基因列表对每个 instance 的打分，是绝对数值。 </p><p><strong>ATC</strong>是指该药物的 ATC code 值，是一种国际通用的药物分类系统。 </p><p><strong>instance_id</strong>是指每个 instance 的标识 ID。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Connectivity Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物码农 VS 计算生物学家</title>
      <link href="/2019/08/25/%E8%AE%A1%E7%AE%97%E7%94%9F%E7%89%A9%E5%AD%A6%E5%AE%B6/"/>
      <url>/2019/08/25/%E8%AE%A1%E7%AE%97%E7%94%9F%E7%89%A9%E5%AD%A6%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<p>摘要：时常在生物学招聘广告上看到招聘生物信息分析员、生物信息分析工程师、生物信息科学家甚至计算生物学家。所需要的学历、技能、经验依次成倍增加。生物码农是对会编程、跑流程，在公司里做着重复机械数据分析和文档写作工作的生信人的戏称。而计算生物学家则往往是在高校和研究所中独当一面的 PI。本文是一篇译文，两名计算生物学家给出了一些计算生物学领域的注意事项和建议。<br><a id="more"></a></p><h2 id="《所以，你想成为一名计算生物学家？》"><a href="#《所以，你想成为一名计算生物学家？》" class="headerlink" title="《所以，你想成为一名计算生物学家？》"></a>《所以，你想成为一名计算生物学家？》</h2><h3 id="原文信息：Loman-Nick-and-Mick-Watson-“So-you-want-to-be-a-computational-biologist-”-Nature-biotechnology-31-11-2013-996"><a href="# 原文信息：Loman-Nick-and-Mick-Watson-“So-you-want-to-be-a-computational-biologist-”-Nature-biotechnology-31-11-2013-996" class="headerlink" title="原文信息：Loman, Nick, and Mick Watson. “So you want to be a computational biologist?.” Nature biotechnology 31.11 (2013): 996."></a>原文信息：Loman, Nick, and Mick Watson. “So you want to be a computational biologist?.” Nature biotechnology 31.11 (2013): 996.</h3><p>计算生物学家往往身兼多个角色，包括数据分析工程师、数据管理员、数据库开发工程师、统计分析师、数学建模工程师、生物信息学工程师、软件开发工程师、存在论支持者等等。显然计算机是现代生物学研究的重要组成部分，生物学家们需要掌握计算生物学所要求的新技能和新技术。无论你是生命科学领域的一名研究生、一位教授或者其他什么人，如果你发现计算分析对你的研究越来越重要，请遵循下面的建议，沿着这条成为一名计算生物学家的路走下去!</p><h3 id="明确你的目标并选择合适的研究方法"><a href="# 明确你的目标并选择合适的研究方法" class="headerlink" title="明确你的目标并选择合适的研究方法"></a>明确你的目标并选择合适的研究方法 </h3><p> 要想学好计算生物学，关键是选择和使用适当的软件。在您能够合理地解释软件的输出结果之前，您必须了解软件在做什么（内部工作原理是什么）。就像如果你对聚合酶链反应的方法和原理没有基本的了解，你就不会进入实验室进行聚合酶链反应实验。对于计算生物学来说，为什么也要这样做呢? 因为理解软件的底层工作原理和算法有助于合理地解释输出结果。这并不意味着您需要通读每一行源代码，但是您应该对软件的基本原理和算法有概念上的了解。</p><p>软件工具通常是特定算法的实现，该算法可能非常适合特定类型的数据，例如在从头组装序列（de novo assembly)中，Overlap-Layout-Consensus 类软件适用于对长序列的组装，而 de Bruijn graphs 类软件则适合短序列的组装。选择采用最合适算法的软件将会为您节省大量时间。</p><h3 id="为自己和他人的脚本设置正负对照"><a href="# 为自己和他人的脚本设置正负对照" class="headerlink" title="为自己和他人的脚本设置正负对照"></a>为自己和他人的脚本设置正负对照 </h3><p> 您如何知道您的脚本、软件或流程正在正确地工作? 计算机会经常会基于奇怪的输入数据输出分析结果，而且没有任何报错信息，但这并不意味着没有问题。基于已知输出结果的小数据集进行测试（预实验），检查软件或分析流程是否能够重现该结果。试着对你希望找到的每一种类型的答案都这样做。仔细检查每种测试的结果，看看这些结果是否有意义。如果没有必要的正负对照，湿实验科学家是不会想着进行实验的，而这些测试在计算生物学实验中也发挥着同等作用。</p><h3 id="你是个科学家，不是程序员（码农）"><a href="# 你是个科学家，不是程序员（码农）" class="headerlink" title="你是个科学家，不是程序员（码农）"></a>你是个科学家，不是程序员（码农）</h3><p>要求太高反而难成功。你是一个科学家，科学研究工作完成的质量比你的源代码看起来有多漂亮更重要。如果输出结果是错误的，代码编写得再完美、文档再丰富、再优雅，那么它就是不如能输出正确结果的简单脚本有用。话虽如此，一旦您确定您的核心算法能够正常且正确地工作，就应该花点时间使它变得优雅些，并写出它的使用文档。尽可能多地运用你的生物学知识——这是你成为计算生物学家的根本。</p><h3 id="使用版本控制软件"><a href="# 使用版本控制软件" class="headerlink" title="使用版本控制软件"></a>使用版本控制软件 </h3><p> 版本控制软件能够跟踪你对代码的更改，帮助您维护多个版本的代码并与其他人协作。使用标准工具，如 Git 或 Subversion，您就可以轻松地发布代码。善待未来（那个阅读代码或者修改代码）的自己。解释您写代码时所做的选择以及您为什么要做这些选择的 ReadMe 文件，将在几个月或几年之后您返回到某项目时成为一件好事。编写代码和脚本的说明文档，以便帮自己和他人理解它们的作用。当发布您的研究成果时，请尝试同时发布用于生成研究结果的脚本和方法，以便其他人可以复制、重现它们。还可以考虑在你进行数据分析的时候，用一个数字化实验室记录本来记录你的分析结果。云存储数据库 (如 Github) 是理想的选择，它还可以帮助您维护存储库的副本并以此作为分析结果的离线备份。</p><h3 id="问问自己是否需要流程化"><a href="# 问问自己是否需要流程化" class="headerlink" title="问问自己是否需要流程化"></a>问问自己是否需要流程化 </h3><p> 流程化是指一系列按照预设的计划依次运行的脚本或软件工具。流程化非常适合以重复的方式运行完全相同的一组步骤以及与他人共享协议。但流程化可能会迫使您采用一种僵化的思维方式而降低创新性。警告: 不要过早地把自己的工作流程化。在将一个方法转换为一个流程之前，先让它正常工作。即便如此，它是否需要成为一个流程? 这样能节省时间吗? 你的流程真的对别人有用吗? 如果这些步骤只由您来操作，而一个简单的脚本可能就足够，那么任何尝试流程化的操作将是浪费时间。类似地，如果这些步骤只运行一次，那么就只运行一次而不必流程化，记录下您曾经运行过这些步骤，然后继续下去。</p><h3 id="奥巴马式思维模式"><a href="# 奥巴马式思维模式" class="headerlink" title="奥巴马式思维模式"></a>奥巴马式思维模式 </h3><p> 是的, 你可以的!（YES，YOU CAN！）作为一个计算生物学家，你需要有创造性，从改进现有的计算方法到达开发全新的方法的境界。也要敢于冒险，做好失败的准备，更要坚持下去。通过使用谷歌，请教领域内的专家，自学如何解决特定的问题，你也可以取得惊人的成就。参加培训课程也是有用的，但这些只是成为计算生物学家的学习的开始，而不是结束。之后继续坚持自学。</p><h3 id="科研需要质疑精神，尽信文献不如无文献"><a href="# 科研需要质疑精神，尽信文献不如无文献" class="headerlink" title="科研需要质疑精神，尽信文献不如无文献"></a>科研需要质疑精神，尽信文献不如无文献 </h3><p> 统计学训练中进行往往包含多个实验。首先，创建一个由随机数组成的大矩阵，并将列指定为实验组或对照组。然后对每一行进行统计测试，以分析实验组数据和对照组数据之间是否存在显著的差异。您将毫不惊讶地发现，得到的结果中有几百行的 P 值具有统计显著性。生物数据集（比如基因组学实验产生的数据集）庞大而充满噪音。您的数据分析将产生假阳性和假阴性结果，而且在实验中或分析中的数据也可能会引入系统性偏差。</p><p>即使在受过统计学理论训练的生物学家中，也有一种倾向，即当特定的软件或流程产生有趣的结果时，他们会把谨慎和怀疑精神抛诸脑后。而真正需要做的是：对结果持怀疑态度，并进行进一步的测试，以确定“有趣的”结果是否可以用实验误差或偏差来解释。如果多种方法结果一致，那么你就能提升对这些答案的信心。但对于许多实验的结果，需要进一步的实验室验证和分析工作。在解释计算生物学的分析结果时，生物学知识是至关重要的。如上所述，设置正负对照或测试只是计算生物学的一部分。这些测试旨在确保您的软件或分析流程按照您的预期在工作，即使如此这并不一定意味着所得到的答案是正确的。</p><h3 id="适合进行计算生物学分析的工具"><a href="# 适合进行计算生物学分析的工具" class="headerlink" title="适合进行计算生物学分析的工具"></a>适合进行计算生物学分析的工具 </h3><p> 您要熟练使用 UNIX/Linux 命令行进行工作。命令行的功能非常强大，它允许您更好地控制软件去做什么，并允许您同时运行和控制多个作业。大多数生物信息学软件的设计就是基于命令行运行的。您还需要了解计算集群以及如何并行运行数百个作业。你需要能够编写代码，但是编程语言种类的选择并不像计算机科学家所认为的那么重要。每种编程语言都有优缺点，你可能不得不使用多种语言来完成工作。</p><p>选择一种更流行的语言将使您受益，因为存在着更大的工具集库，例如来自 Open Bioinformatics Foundation 的 Bio* 项目。Microsoft Excel 是一个电子表格程序，除非非常小心地使用，否则不适合生物数据的存储和分析。建议将实验数据存储在结构化文本文件或 SQL 数据库中。采用基本的数据库操作方法，如数据标准化，可以使出错的机会更少。建议所有数据都定期备份。</p><h3 id="像侦探一样思考"><a href="# 像侦探一样思考" class="headerlink" title="像侦探一样思考"></a>像侦探一样思考 </h3><p> 作为一名计算生物学家，您将花费大量时间分析和解释数据。数据在告诉你一些事情。它们蕴含了一个故事，你的工作就是找出这个故事是什么。除非你非常幸运，大多数时候它不会显而易见。查明真相并不容易。你必须考虑实验是如何进行的、数据分析是如何进行的以及结果告诉你什么。你需要自信地忽略或控制数据中的错误和系统性偏差。要做到这一点，你可能需要与参与这项工作的其他科学家交谈，或者整合和分析额外的数据。您可能需要设计后续实验来测试您提出的任何实验假设。记住，真实的故事可能根本不出自您的数据中! 比如，如果你感兴趣的生物系统依赖于蛋白质的磷酸化，那么你可能不会在 RNA-seq 数据中看到这种效果。计算生物学家基本上是个侦探，折腾数据并发现真相。</p><h3 id="站在巨人的肩膀上"><a href="# 站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上 </h3><p> 你在做的工作很可能已经有人已经在研究过了，找到他们! 无论你的研究问题多么棘手，研究方法多么先进，很有可能已经有人尝试过解决它了。讨论软件相关问题的两个优秀资源是 <a href="http://www.biostars.org/" target="_blank" rel="noopener">BioStars</a> 和<a href="http://seqanswes.com/" target="_blank" rel="noopener">SEQanswers</a>。Twitter 是另一个你可以找到建议、资源和论文链接的地方。也可以与你所在系或研究所的其他计算生物学家联系。在您的领域也可能会有一个本地的计算生物学会议或兴趣小组，所以找到它并加入。如果没有，为什么不像尼克（本文作者之一）那样自己组建一个呢? 总之，如果您想进行计算生物学分析，可以通过在线和本地研究人员获得大量支持。有足够的勇气去尝试并从这些资源中学习是最好的起点。在你的电脑上安装 Linux 操作系统并开始学习一些在线的学习材料。你会惊讶于你能很快上手做出一些什么东西，最终这将成为你一个非常有益的经验!</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h3>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 译文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物网络的概念（一）：毗邻矩阵（Adjacency Matrix）</title>
      <link href="/2019/06/04/networkConcepts1/"/>
      <url>/2019/06/04/networkConcepts1/</url>
      
        <content type="html"><![CDATA[<p><strong> 网络的毗邻矩阵 </strong><br>&ensp;&ensp;&ensp;&ensp; 网络主要由节点（node）和边（edge）组成，是一种研究节点与节点相互关系的重要工具，如描述蛋白质之间相互作用的蛋白质相互作用网络，描述基因之间共表达关系的基因共表达网络等等。<a id="more"></a><br>&ensp;&ensp;&ensp;&ensp; 毗邻矩阵（Adjacency matrix）是一种描述网络中相邻两个节点连接程度（connection strength）的 n×n 维矩阵。设有一个毗邻矩阵 A，可以写成如下格式：</p><center> $A = (A_{ij})$ </center><p>&ensp;&ensp;&ensp;&ensp; 其中 Aij 分别表示第 i 个和第 j 个节点的毗邻值（可以理解为两个节点的相互关系强弱）。对于无加权网络（unweighted network）来说，若两个节点的相互关系大于某个阈值则 Aij 等于 1；反之，则这个值为 0。总而言之，无向网络（undirected network）的毗邻矩阵的性质如下：</p><center> $0 \leq A_{ij}  \leq1$ </center> <center> $A_{ij} = A_{ji}$ </center><center> $A_{ii} = 1$ </center> <hr><p><strong> 总连接度（connectivity)及其相关概念 </strong><br>&ensp;&ensp;&ensp;&ensp; 网络的总连接度 (connectivity) 又叫度(degree)。它的计算公式如下：</p><center> $k_i = \sum_{j \neq i}A_{ij}$ </center> <p>&ensp;&ensp;&ensp;&ensp; 在无加权网络中，节点 i 的总连接度 ki 就等于与节点 i 连接的所有点的总数目。<br>&ensp;&ensp;&ensp;&ensp; 在加权网络中，节点 i 的总连接度等于与节点 i 连接的各个点毗邻值（Aij)的总和。如下图所示：</p><p><img src="/2019/06/04/networkConcepts1/connectivity.PNG" alt></p><hr><p><strong> 社交网络分析：感染网络（Affection Network） </strong></p><p>&ensp;&ensp;&ensp;&ensp; 马克思曾给人下了个定义：人是各种社会关系的总和。可以通过人际关系网络来理解理解网络的基本特性。把人作为网络（人际关系网）的节点，两个人（节点）的亲近程度作为他们之间的感染力（毗邻值）。我们可以这样假设：两个人强烈地喜欢欣赏对方，那么他们之间的感染力就非常强（毗邻值 Aij 就等于 1）；若他们彼此无感、不感染（但也不排斥，Aij 就等于 0.5）；若他们彼此极度厌恶，那么没有一点感染力（Aij 就等于 0）。最终某个人与所有人的连接度之和（标化花后）可以作为他的受欢迎程度（connectivity)，这个 connectivity 值越大说明这个人越受人爱戴。</p><blockquote><p>参考资料：Horvath, Steve. Weighted network analysis: applications in genomics and systems biology. Springer Science &amp; Business Media, 2011.</p></blockquote><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center> END </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生物网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《被伤害和侮辱的人们》读后感</title>
      <link href="/2019/06/01/%E8%A2%AB%E4%BC%A4%E5%AE%B3%E5%92%8C%E4%BE%AE%E8%BE%B1%E7%9A%84%E4%BA%BA%E4%BB%AC/"/>
      <url>/2019/06/01/%E8%A2%AB%E4%BC%A4%E5%AE%B3%E5%92%8C%E4%BE%AE%E8%BE%B1%E7%9A%84%E4%BA%BA%E4%BB%AC/</url>
      
        <content type="html"><![CDATA[<p><strong> 阅读后的思考（一）</strong><br>&ensp;&ensp;&ensp;&ensp; 近一段时间读完的一部长篇小说（继白鹿原、沉默的大多数、遥远的救世主、天幕红尘），感觉没有读完其他小说之后产生的震撼，虽然是俄国著名作家陀思妥耶夫斯基的著作。<a id="more"></a><br>&ensp;&ensp;&ensp;&ensp; 这部小说是我读过的第二部俄国文学作品（第一部是《钢铁是怎样炼成的》，奥斯特洛夫斯基作品）。先说中俄作家文风的区别，这部作品给人的感觉有点像戏剧，表演的色彩比较浓重，一幕一幕的。人物对白总有各种感叹、惊叹、感慨，可能为了呼应作品题目的悲剧色彩，小说中的人物（娜达莎、涅莉、娜达莎母亲）悲伤哭泣的场景非常多。而我国作家的作品（我所读过的），虽然作品中的主人公也有悲惨的经历，但是作者虽然也会刻意描写他们的悲伤情绪，会更加着重描写小说中人物的内心世界及其变化，着重描写小说人物悲惨经历后的思想变化以及对世界对人生感悟的升华。<br>&ensp;&ensp;&ensp;&ensp; 这部小说描写了一场畸形的爱情及其悲剧结局。以第一人称（瓦尼亚）的视角，来描写这场爱情悲剧。两小无猜青梅竹马的瓦尼亚和娜达莎已经私定终身了，却因公爵儿子的到来使得瓦尼亚痛失爱人。瓦尼亚痛心疾首，但是还是与娜达莎和平放手，更令人佩服的是他还继续做娜达莎的朋友，在危难时替娜达莎分担痛苦，成为其蓝颜知己。然而娜达莎和公爵儿子的爱情注定以悲剧收场。原因有以下两点：<br>&ensp;&ensp;&ensp;&ensp; 一、他们之间的感情不是成熟的爱情，而是依恋。公爵儿子在娜达莎眼里就是一个孩子，她爱的是其天真、真诚、诚实的品性，而公爵儿子则看中娜达莎的包容、溺爱之类的母性。他们之间的感情像母子之情。而比较好的爱情则应该是以平等为基础，彼此之间互相爱恋。母子之情，天生就是不平等的，一方只有付出，并且还是无私的付出，而另一方理所当然地接受。所以，当公爵儿子厌烦这种母爱的时候或者从另外的人那里也能得到满足的时候，他很可能就会离开娜达莎。<br>&ensp;&ensp;&ensp;&ensp; 二、家族仇恨，公爵和娜达莎父亲的私怨。他们之间的私人恩怨已经达到不共戴天的程度了，娜达莎竟然不管不顾，追逐仇人的儿子而去。这种追求爱情的方式不敢苟同，典型的自私行为。为了追求自己个人的幸福，给已经受到伤害的父母二次伤害。背负这样的心理负担，他们不可能收到世人认可。人毕竟是社会动物，被社会所遗弃，没有世人的认可，成为只有爱情的孤家寡人，应该很难长久维持爱情吧。<br>&ensp;&ensp;&ensp;&ensp; 爱情这东西真有这么厉害？能让人变成魔鬼也在所不惜？让人六亲不认？<br>&ensp;&ensp;&ensp;&ensp; 公爵是这部小说两条主线的链接人物。公爵——&gt; 公爵儿子——&gt; 娜达莎——&gt; 娜达莎父亲——&gt; 瓦尼亚，公爵——&gt; 涅莉母亲——&gt; 涅莉——&gt; 涅莉外公——&gt; 瓦尼亚。公爵这种人，就是唯利是图、见利忘义、蛇蝎心肠的典型代表，但是坏人、恶人也是有他们智慧、客观的一面。他对于道德的理解也让人眼前一亮：道德（德性）其实是一种方便，道德完全是为了方便而发明的。想想也是有道理的，许多好的品德，如善良，自己善良别人可能觉得你对他没有攻击性，给人安全感，这样容易取得别人的信任和接纳；比如孝顺，孝顺自己父母，也可能是为了为自己儿女树立榜样，将来自己的儿女可能也这样对待自己等等。所以，那些标榜自己品德高尚的正人君子，没必要太骄（孤）傲，其实也是某种程度的利己之人。归根到底，人类的许多行为都是为了追求利己的。有的人利己能双赢，得到赞颂，成为高德之人；有人利己会损人，成为卑鄙小人，罪人。仓廪足而知礼节。只有神、上帝才可能只为别人不为自己。为什么捏？上帝啥都不缺，所以他可以啥都给。而我们凡人，总有这样那样的缺憾，所以不可能完全无我而利他。不要把别人想的那么坏，也不要把自己想的那么好，都是凡人而已。</p><hr><p> 摘抄：  </p><blockquote><p> 一缕迷路的阳光大概是出于好奇，朝我的屋子里瞥了一眼。</p><p> 爱情总要过去的，而差异总是会保存下来。</p><p> 人类一切美德的基础乃是最深刻的利己主义。一件事越是合乎道德，其中的利己成分就越多。</p></blockquote><hr><h1 id="END"><a href="#END" class="headerlink" title="END"></a><center>END</center></h1>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《遥远的救赎主》（豆豆著）读后感</title>
      <link href="/2019/05/25/%E9%81%A5%E8%BF%9C%E7%9A%84%E6%95%91%E8%B5%8E%E4%B8%BB%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2019/05/25/%E9%81%A5%E8%BF%9C%E7%9A%84%E6%95%91%E8%B5%8E%E4%B8%BB%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p><strong> 阅读后的反思（一） </strong><br><strong> 这部作品提出的得救之道是什么？</strong><br>&ensp;&ensp;&ensp;&ensp; 这部作品有大段篇幅对神、天道、得救之道进行讨论，这样的讨论让人感觉很高深、玄幻。要回答得救之道是什么，可以先回答一下谁需要得救？<a id="more"></a> 仅就这部作品而言，邓世杰等烧友以及王庙村的农民需要得救，需要从水深火热的贫困县的贫困村中发家致富。那么这些人是如何寻求得救之道呢？村民信基督教，说信耶稣便得救了。烧友信高人，信高人便得救了。从而引申出本书的核心话题：文化属性。中国的文化属性充斥着救主文化特征。什么事都要去依靠 xx、投靠 xx，靠一两个英雄拯救，靠贤明君主布施、恩宠，无非就是想要破格获取。丁元英通过表面上平实无奇的招数为王庙村、烧友们上了一堂“得救之道到底是什么”的教学实践课。<br>&ensp;&ensp;&ensp;&ensp; 作者（豆豆）的观点是：“能否得救完全取决于自己，从来没有救世主，要想得救就要实事求是。如果一定要讲救世主的话，那么符合和代表客观规律的文化就是救世主。”<br>&ensp;&ensp;&ensp;&ensp; 以下是文章摘抄，可能作为这个问题的回答：</p><blockquote><p>&ensp; 民无主，并非真的无主，而是没有对客观规律认识的主，只依赖强者道德的主，即为“你要为我做主”。<br>&ensp; 翻开历史，找不到一处救世主救人的记录。从来都是救人的被救了，被救的救了人。从来没有什么救世主，那么我们脆弱的人类该怎样在这个孤独的星球立足？认识客观规律并掌握它，便成了自己的救世主。</p></blockquote><p><strong> 如何看待芮小丹的结局？</strong><br>&ensp;&ensp;&ensp;&ensp; 如果她不自杀，结局可能有几种：<br>&ensp;&ensp;&ensp;&ensp;1）背负残缺的身子过一生；<br>&ensp;&ensp;&ensp;&ensp;2）被追授为烈士，成为人们敬仰和怜悯的对象。<br>&ensp;&ensp;&ensp;&ensp; 如果只是身体中了一颗子弹，小丹必不会自杀。然而她已经是一个残废、面目全非之人，失去了美丽的面容和独立的行动能力。这些都可能使她因自卑离开丁元英，也可能被丁元英抛弃。要靠别人才能活下去，失去自主、自立。自主、自立对于小丹来说是生命赖以维持下去的根本动力。<br>&ensp;&ensp;&ensp;&ensp; 丁元英的回答是：“因为她认为自己没用了”。当活着只是给家庭、社会增加负担之外毫无意义，那么对于小丹这种明心见性的女人来说，自杀可能是自觉的选择。当发觉自己没有价值了，是否能有勇气结束自己的生命？当生则生，当死则死。这就是客观规律，没有一点道德情义可讲。<br>&ensp;&ensp;&ensp;&ensp; 这一点很像笔者今年英语口语课上的临终关怀话题。其中一个观点是人需要在清醒、没病没灾的情况下提前计划自己完全失去意识时是否继续救治，是否要在处于植物人状态下仍然维持生命。如果活下去没有意义，那么潇洒转身离开才是明智选择，自己不受罪，他人也不受罪。</p><p><strong> 如何理解“神即道，道法自然，如来”？</strong><br>&ensp;&ensp;&ensp;&ensp; 救世主，也就是所谓的神，就是代表客观规律的文化（道），道来自于客观（自然），不以人的意志为转移，一切以时间、地点和条件为转移。  </p><blockquote><p>&ensp; 原来能说老实话、能办老实事的人就是神，能做到实事求是就是神话。实事求是，就是按照客观规律说话、办事。</p></blockquote><p><strong> 《遥远的救世主》这个题目与文章主题有何关联？</strong><br>&ensp;&ensp;&ensp;&ensp; 遥远的救世主、天国的女儿，这些提法都有意或无意地暗示人们根本没有什么救世主，要把自己头脑中的救主思想改造，学习并掌握客观规律，自己拯救自己。</p><p><strong> 文化属性是什么？</strong><br>&ensp;&ensp;&ensp;&ensp; 任何对象（object）都有属性（attribution)，人类社会也不例外。文化属性，这个词乍看有点虚空、有点大有、点泛。这东西有什么用呢？竟然还有人关注这个东西。人的思维层次不同，关注的问题的内容和角度也不一样。这部小说在给读者传达一种思想：掌握了文化属性就掌握了透视人类社会的方法。所以你没意识的东西并不一定代表不存在，你没意识到的东西很可能正是你现在或者将来问题的答案和钥匙。</p><blockquote><p>&ensp; 支配人的价值取舍行为的那个东西就是主，就是文化属性。<br>&ensp;&ensp; 作者并未直接给出文化属性的定义。而是说它包含了什么：<br>&ensp; 透视社会依次有三个层面：技术、制度和文化。小到一个人，大到一个国家，任何一种命运归根到底都是文化属性的产物。文化有强弱之分。强势文化造就强者，弱势文化造就弱者，这是规律，也可以理解为天道，不以人的意志为转移。</p></blockquote><p><strong> 强势文化与弱势文化及其在国人身上的体现？</strong></p><blockquote><p>&ensp; 强势文化就是遵循事物规律的文化；弱势文化就是依赖强者的道德，期望破格获取的文化，也就是救世主文化。强势文化在武学上被称为秘笈，而弱势文化由于易学、易懂和易用成了流行品种。  </p></blockquote><p>&ensp;&ensp;&ensp;&ensp; 体现：“出门靠朋友，在家靠父母”、“官本位”、“送礼、走后门”、“酱缸文化”。</p><p><strong> 如何理解透视社会的三个层次？</strong><br>&ensp;&ensp;&ensp;&ensp; 做人也好、工作也好，都有层次之说。王国维所说人生三境界，佛教所说悟道三境界，独孤求败武术精进的几层境界。事物是有层次之分的，由易到难，由浅入深。如果不求上进，不思进取，那么可能永远都是井底之蛙，原地踏步。<br>&ensp;&ensp;&ensp;&ensp; 透视社会的三个层次：技术、制度和文化。技术，代表了这个社会的生产力水平，制度代表了这个社会的运行方式，而文化代表了这个社会的价值取向。技术、制度都是文化的产物，要想改变技术、制度，可能需要从文化属性的改变入手，毕竟降维打击比较容易。</p><p><strong> 丁元英为什么最后能够逼迫乐圣公司合作？</strong><br>&ensp;&ensp;&ensp;&ensp; 一种思考方式：<br>&ensp;&ensp;&ensp;&ensp; 从狼嘴里夹肉，杀富劫贫 &lt;——以子之矛攻子之盾，逼迫对方合作 &lt;——先给对方一个陷阱（格律诗的国际名声也给乐圣以甜头，打价格战），时机的选择，以扩大最大影响力为目的（音响博览会）&lt;——王庙村生产产品 &lt;——王庙村现状 </p><p>&ensp;&ensp;&ensp;&ensp; 丁元英不做格律诗股东让欧阳雪掌握股权的考虑：<br> 丁元英预料到公司会与乐圣打官司，有可能会陷入危机，这时小农的“自保意识、求生本能”会使公司陷入四分五裂的境况，如果让被恐惧吓到的人掌握公司的决定权，那么公司必定破产无疑。所以要选一位对自己信赖的人做董事长。</p><p><strong> 杀富济贫为什么救不了贫？救主文化在国人、中国历史上的体现。</strong><br>&ensp;&ensp;&ensp;&ensp; 杀富富不去，济贫贫不离。因为贫富都是文化属性的产物，不改变思想，不去认识客观规律，那么人还是会走老路。特别是穷人，还是陷入等待救主的思维。</p><blockquote><p>&ensp; 弱势群体得到的输血越多，自身的造血功能就越差，越接近死亡。不改变造血功能，就解决不了造血问题，就谈不上救济。</p></blockquote><p><strong> 对大爱不爱的理解。</strong><br>&ensp;&ensp;&ensp;&ensp; 丁元英去五台山上寻求一个心理安慰，大师一句话给他吃了一颗定心丸：大爱不爱。爱有时候也是一种毒药，它让受让者破格获取，灰姑娘的故事等等，最终不会让受让者拥有造血功能。道德也是这样。从根本上说，人性中包含着兽性，现代社会像一个钢筋水泥的丛林，在丛林里就有丛林法则：弱肉强食，优胜劣汰。仅仅靠道德和爱来给弱势群体输血是不能让他们在这个丛林里存活的。得让他们在不断地生存斗争中磨练出一套认识客观规律和掌握客观规律的本事，才是大爱。</p><blockquote><p>&ensp; 天地不仁以万物为刍狗，圣人不仁以百姓为刍狗是也。不要用道德来谴责强者和怜悯弱者。<br><strong> <center>END</center></strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
